## 锁

### TCP场景

- 进程上下文
- 中断上下文

由于进程上下文对socket的low锁占有，中断上下文将skb排入次level的backlog队列，当进程上下文释放low锁的时候，顺序执行次level被排入的任务，即处理backlog中的skb。

### UDP场景

UDP是无状态的，收包和发包都无需事务，协议栈对UDP的处理，从来都是单个报文粒度的，因此只需要保护唯一的socket接收队列即可，即 sk_receive_queue

需要一把锁就可以，不需要像TCP那样复杂

## DPDK vs 内核

为什么DPDK处理UDP收包效率那么高？

答案很简单， DPDK是在进程上下文轮询接收UDP数据包的。也就是说，它摆脱了两个问题：

1. 进程上下文和中断上下文操作共享数据的锁问题。
2. 进程上下文和中断上下文切换导致的cache miss问题。

这两点其实也就是 “为什么内核协议栈性能干不过用户态协议栈” 的要点。

1. 不同的上下文异步操作同一份数据，锁是必不可少的。
2. 仅就cache来讨论，中断上下文和进程上下文之间的切换，也有一个明显的case：


## 参考

- [Linux内核UDP收包为什么效率低？性能怎么优化(超详细讲解)](https://zhuanlan.zhihu.com/p/457481940)
