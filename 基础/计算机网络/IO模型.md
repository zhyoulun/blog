Unix下可用的5种I/O模型的基本区别：

- 阻塞式I/O
- 非阻塞式I/O
- I/O复用（select和poll）
- 信号驱动式I/O（SIGIO）
- 异步I/O（POSIX的aio_系列函数）

一个输入操作通常包含两个不同的阶段：

1. 等待数据准备好
2. 从内核向进程复制数据

对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区，第二步就是把数据从内核缓冲区复制到应用进程缓冲区。

## 阻塞式I/O模型

![](/static/images/2006/p023.png)


## 非阻塞式I/O

![](/static/images/2006/p024.png)

当一个应用进程像这样对一个非阻塞描述符循环调用recvfrom时，我们称之为轮询（polling）。

应用程序持续轮询内核，以查看某个操作是否就绪。

这么做往往耗费大量CPU时间，不过这种模型偶尔也会用到，通常是在专门提供某一种功能的系统中才有。

## I/O复用（select和poll）

![](/static/images/2006/p025.png)

## 信号驱动式I/O（SIGIO）

![](/static/images/2006/p026.png)

## 异步I/O（POSIX的aio_系列函数）

![](/static/images/2006/p027.png)

异步I/O由POSIX规范定义。演变成当前POSIX规范的各种早期标准所定义的实时函数中存在的差异已经取得一致。???

一般的，这种函数的工作机制是：告知内核启动某个操作，并在内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们。

这种模型和信号驱动模型的主要区别是：后者是由内核通知我们何时可以启动一个I/O操作，而前者是由内核通知我们I/O操作何时完成。

## 各种I/O模型的比较

![](/static/images/2006/p028.png)
