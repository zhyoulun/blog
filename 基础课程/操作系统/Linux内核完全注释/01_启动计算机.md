
### 基本知识


#### 两代ROM BIOS的关系

1981年IBM PC机刚推出时，系统只带有640KB的RAM主存储器。由于所采用的8088/8086 CPU只有20根地址总线，因此内存寻址范围最高为1024KB（1MB，`2^20=2^10*2^10=1MB`）。

随着计算机软件和硬件技术的高速发展，目前的计算机通常配置有512MB或者更多的物理内存容量，并且都采用Intel 32位CPU，因此CPU的物理内存寻址范围达到4GB（2^32）。

但是为了与原来的PC机在软件上兼容，系统1MB以下物理内存使用分配上仍然保持和原来的PC机基本一致。只是原来系统ROM中的基本输入输出程序BIOS一直处于CPU能寻址的内存最高端位置处，而BIOS原来所在的位置将在计算机开机时初始化时被用作BIOS的影子区域，即BIOS代码仍然会被复制到这个区域中。

![](/static/images/2204/p014.png)

#### 兼容性复制的流程

当计算机系统上电开机或者复位时，CPU会自动把代码段寄存器CS设置为0xF000，段基地址被设置为0xFFFF0000，段长度设置为64KB。IP被设置为0xFFF0。则此时CPU代码指针指向0xFFFFFFF0(=Base+IP=0xFFFF0000+0xFFF0)，即4GB空间最后一个64KB的最后16字节处，这里正式系统ROM BIOS存放的位置。BIOS会在这里存放一条指令JMP跳转到BIOS代码64KB范围内的某一条指令开始执行。

BIOS在执行了一系列硬件检测和初始化操作后，就会把与原来PC机兼容的64KB BIOS代码和数据复制到内存低端1M末端的64KB处，然后跳转到这个地方，并让CPU进行真正的实地址模式工作。

最后BIOS就会从硬盘或者其它块设备把操作系统引导程序（bootloader）加载到内存0x7c00处，并跳转到这个地方继续执行引导程序。

![](/static/images/2204/p015.png)


#### 实模式下BIOS具体是如何拿到bootloader

如果硬盘或者软件是首选的启动设备，BIOS会读取其中的0柱面0磁道1扇区，并检测是否为可引导设备（可引导的标志是扇区的最后两个字节为0x55和0xAA），如果是的话，这个扇区将会被加载到内存0x7c00处并被执行。

一个扇区的大小是512字节

#### BIOS程序超过64KB的处理办法

新一代的ROM BIOS的容量大多有1MB到2MB，存储在ROM中，因此为了能够执行或者访问BIOS中超过64KB范围，并且又远远不在`0~1MB`地址空间中的其他BIOS代码或者数据，BIOS程序会首先用一种称为32位大模式技术把数据段寄存器的访问范围设置为4GB，而非原来的64KB，这样就可以在0~4GB范围内执行和操作数据。

### 实验

这个实验需要在ubuntu desktop上测试

做一个空的image

```bash
dd if=/dev/zero of=disk.img bs=1024 count=100 # 创建一个100KB的全0文件
xxd -a disk.img # 查看文件内容
qemu-system-i386 disk.img # 启动
```

![](/static/images/2204/p017.png)

将第一个扇区增加可引导标志

```bash
hexedit disk.img # 修改510字节、511字节两位置的值分别是0x55和0x77
# ctrl+x可以保存结果
qemu-system-i386 disk.img # 启动
```

![](/static/images/2204/p016.png)

## 参考

- Linux内核完全注释，2.3，主存储器、BIOS和CMOS存储器
- [汇编语言一发入魂 0x00 - 计算机是如何启动的?](https://kviccn.github.io/posts/2020/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%80%E5%8F%91%E5%85%A5%E9%AD%82-0x00-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8%E7%9A%84/)
