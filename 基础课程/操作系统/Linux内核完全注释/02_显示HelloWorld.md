### 基础知识

#### 基本思路

要在屏幕上打印字符就需要对显存进行操作。如何操作显存呢？

计算机启动时，显卡被初始化为文本模式，对应的显存也被映射到了0xb8000到0xbffff这段物理地址空间。所以直接向这段内存写数据，屏幕上就能够打印出对应的字符。

#### CGA显示标准

彩色图形适配器（color graphics adapter）支持了7中彩色和图形显示方式（BIOS显示方式0\~6）。在80列x25行（80*25=2000）的文本字符显示方式下，有单色和16色彩色两种显示方式（BIOS显示方式2\~3）。CGA卡标配有16KB显示内存（占用内存地址范围0xb8000~0xbc000），因此其中共可以存放4帧显示信息。在每一帧4KB(4096)显示内存中，偶地址字节存放字符代码，奇地址字节存放字符显示属性。

![](/static/images/2204/p019.png)

![](/static/images/2204/p020.png)

### 练习

代码

```nasm
.code16

movw $0xb800, %ax
movw %ax, %es

movb $'H', %es:0
movb $0xa, %es:1

jmp .

.org 510
.word 0xAA55
```

- 第1行告诉编译器以16位模式编译，因为BIOS在加载并运行我们的代码时是处于16位实地址模式的。
- 第3、4行将附加数据段寄存器es的内容设置为0xb800。mov是数据转移指令，mov后面的w表示操作数的宽度为一个word，即16位的数据。movw $0xb800, %ax表示把立即数0xb800转移到寄存器ax中。其中0xb800是源操作数，ax是目的操作数。根据at&t的规范，立即数前需要加$符，用来和内存地址区分。寄存器前需要加%。这条指令执行完成之后ax寄存器的内容为0xb800，下一条指令又把ax寄存器中的数据转移到es中，完成段寄存器的设置。乍一看这不是多了块鱼吗？为啥不直接把0xb800放到es里？答案是段寄存器在程序运行中的职责比较重要，所以Intel没有提供直接把立即数转移到段寄存器的指令。通过强制多加一个步骤，可以使操作者明白自己到底在做什么，是否真的需要修改段寄存器的值。
- 第6行我们先来分析一下目的操作数%es:0，根据之前的内容我们知道这是以段基址:段内偏移的形式来给出内存地址。此时es的内容为0xb800，左移4位再加上偏移地址0，得到的物理地址为0xb8000。再来康康源操作数'H'，为啥这样写呢？得益于GNU as编译器的支持，我们能够以这种方式表示一个ASCII字符，编译器会帮我们把'H'转换为0x48。接下来康康mov后面的b，b表示byte，因为这次我们只操作一个字节的数据。
- 第7行和第6行基本一致，只不过偏移地址为1，最终的物理地址为0xb8001，0x0a表示浅绿色。
- 第9行是一条跳转指令，.单独使用时是一个特殊的符号，作为位置计数器，表示当前所在行的位置。那么这条指令就表示跳转到当前位置，实现的效果就是死循环。
- 第11、12行用了两条伪指令，伪指令是给编译器看的，并不是处理器最终会执行的指令。.org伪指令指示编译器把位置计数器移动到操作数所指定的位置，这里是将位置计数器移动到510处。.word伪指令指示编译器在当前位置写入一个字大小的数据，当然，操作数也可以用逗号隔开，表示写入一组一个字大小的数据。这里要写入的数据是0xAA55，何以是0xAA55？上次不是才说过第一个扇区的最后两个字节要是0x55、0xAA才能被引导吗？怎么反过来了？这是因为Intel处理器使用的是小端序，即数据的低字节存放在内存的低地址处，高字节存放在内存的高地址处。所以0xAA55在内存中仍然是按照0x55，0xAA的顺序存放的。

编译

```
as --32 boot.s -o boot.o
```

再反编译review下

```bash
$ objdump -D -Mi8086,suffix boot.o

boot.o:     file format elf32-i386


Disassembly of section .text:

00000000 <.text>:
   0:	b8 00 b8             	movw   $0xb800,%ax
   3:	8e c0                	movw   %ax,%es
   5:	26 c6 06 00 00 48    	movb   $0x48,%es:0x0
   b:	26 c6 06 01 00 0a    	movb   $0xa,%es:0x1
  11:	eb fe                	jmp    0x11
	...
 1fb:	00 00                	addb   %al,(%bx,%si)
 1fd:	00 55 aa             	addb   %dl,-0x56(%di)
```

- 使用objdump反编译目标文件。-D参数说明我们要反编译所有的section。根据反编译的结果可以看出来，其实整个程序都被编译到.text段中了。因为我们的源文件中并没有明确的指定代码或者数据所在的段，默认情况下as会把这些代码、数据都放在.text段里。-M参数中指定了以16位模式(i8086)反汇编，同时指定在at&t语法中显示指令后缀(suffix)，这些选项以逗号分隔开。
- 第10行第一个b8是将16位立即数转移到ax寄存器的指令的二进制码，后面的00 b8因为是小端序，所以它表示的数据实际上是b800，很熟悉，对不对？
- 第12、13行，仔细观察可以发现这两条指令前三个字节是相同的，对，它们就是将8位立即数转移到以es为段地址的内存中的指令的二进制码。还是因为是小端序，所以第12行的00 00实际是00 00跟没说一样，第13行的01 00实际是00 01，也就是我们在代码里指定的偏移地址。第12行最后一个字节48，就是'H'的ASCII码对应的16进制表示，as已经帮我们翻译过了，所以我们也就不需要花时间去记每一个字符的ASCII码是多少了。
- 第14行，我们在代码中写的明明是.，到这里却变成了0x11。还记得我们说过.是位置计数器吗？代表了当前行所在的位置，看冒号前面的11，它告诉了我们当前这条指令的位置，jmp 0x11就是反复跳到自己这里执行喽。
- 中间的代码压根没有代码，因为我们是用.org直接跳到510这个位置的，所以从jmp之后到510都是0，objdump很贴心的没有给我们显示。0x1fb处的这个00 00不用管他，毕竟我们把所有东西都放在了代码(.text)段里，objdump也没那么聪明，这不，把我们可引导的标记0x55 0xaa也翻译成了指令。

清理boot.o文件的大小到512B

大于512B的原因是：出现这种结果的原因是as生成的目标文件默认是elf格式的，elf格式的文件中除了二进制代码，还会附加一些头信息、段信息、链接信息、调试信息等等。对与我们这个程序来说，是用不到这些信息的，甚至连链接都不需要，直接把目标文件中的二进制代码复制出来就行了。这个操作我们使用objcopy这个工具来完成。

```bash
objcopy -O binary -j .text boot.o boot.bin
```

-O binary指定输出文件的格式为纯二进制格式，-j .text指定只复制.text段，输出的文件名为boot.bin。

```bash
qemu-system-i386 boot.bin
```

![](/static/images/2204/p018.png)

## 参考

- Linux内核完全注释，2.4.6，显示控制
- [汇编语言一发入魂 0x01 - Hello World](https://kviccn.github.io/posts/2020/03/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%80%E5%8F%91%E5%85%A5%E9%AD%82-0x01-hello-world/)
