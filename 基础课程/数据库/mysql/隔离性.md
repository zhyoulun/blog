不同的隔离级别解决的并发问题

![](/static/images/2203/p025.png)

- 读未提交（READ UNCOMMITTED）
  - 隔离级别最低，并发性能高
  - 事务中的修改，即使没有提交，对其它事务也是可见的。
- 读已提交（READ COMMITTED）
  - 锁粒度：锁定正在读取的行
  - 一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。
- 可重复读（REPEATABLE READ）
  - 锁粒度：锁定所读取的所有行
  - 保证在同一个事务中多次读取同一数据的结果是一样的。
- 可串行化（SERIALIZABLE）
  - 锁粒度：锁表
  - 强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。
  - 该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。

### 并发问题列表描述

#### 脏读

读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。

![](/static/images/2203/p026.png)

#### 不可重复读

不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

![](/static/images/2203/p027.png)

#### 幻读

幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

![](/static/images/2203/p028.png)

## 参考

- [数据库系统原理](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#%E5%85%ABer-%E5%9B%BE)
