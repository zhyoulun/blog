## 缓存穿透，缓存击穿，缓存雪崩

- 缓存穿透是指数据库原本就没有的数据，请求如入无人之境，直奔数据库
- 缓存击穿，则是指数据库有数据，缓存也本应该有数据，但是突然缓存过期了，这层保护屏障被击穿了，请求直奔数据库
- 缓存雪崩则是指很多缓存同一个时间失效了，流量全部涌入数据库，造成数据库极大的压力。

### 缓存穿透

- 定义：使用redis大部分情况都是通过key查询对应的值，假如发送的请求传进来的key是不存在redis中的，那么就查不到缓存，查不到缓存就会去数据库查询。假如有大量这样的请求，这些请求像穿透了缓存一样直接打在数据库上，这种现象就叫缓存穿透
- 解决方案
  - 增加请求validator，做请求的合法性校验
  - 把无效的key存到redis中，如果redis查不到数据，数据库也查不到，把这个key值保存到redis中，设置value=null，这种方式肯定也是有问题的，加入传进来的这个不存在的key值每次都是随机的，那么存进redis也没有意义。
    - 如果数据库有写入，或者更新，必须同时刷新缓存，否则会导致不一致的问题存在
  - 使用布隆过滤器。布隆过滤器的作用是某个key不存在，那么就一定不存在，它说某个key存在，那么大概率存在。所以可以在缓存之前再加一层布隆过滤器，在查询的时候先去布隆过滤器查询key是否存在，如果不存在则直接返回

### 缓存击穿

- 定义：缓存击穿是指一个热点key，有大并发集中对其进行访问，突然间这个key失效了，导致大并发全部打到数据库上，导致数据库压力剧增。这种现象就叫缓存击穿。
- 如何解决：
  - 热点key不设置过期时间
  - 降低打在数据库上的请求量：使用互斥锁，如果缓存失效，只有拿到锁才可以查询数据库，降低在同一时刻打在数据库上的请求，防止将数据库打死，当然这样会导致系统的性能变差。
    - 当然，如果需要更加全面一些，应该加上一个等待次数，比如1s中，如果获取不到锁，等待200ms，最多睡眠5次，打到这个阈值，直接返回为空，不应该过度消耗机器，以免当单个不可用场景时，把整个应用服务器打挂。

### 缓存雪崩

- 当某一个时刻出现大规模缓存失效的情况，那么就会导致大量的请求直接打在数据上面，导致数据库压力增大，如果在高并发情况下，可能瞬间就会导致数据库宕机。这个时候如果马上重启数据库，又会有新的流量把数据库打死。这就是缓存雪崩
- 为什么会出现同一时间大规模key失效
  - 1. redis宕机
  - 2. 采用了相同的过期时间
- 如何解决
  - for 1. 搭建redis集群，提高redis容灾性
  - for 1. 热点数据打散到不同的机房或者机器上
  - for 2. 在原有的失效时间上，加上一个随机值，避免因为采用相同的过期时间导致缓存雪崩
  - for 2. 使用熔断机制。当请求数据库的流量超过一定阈值，直接返回系统拥挤之类的提示，防止过多请求打到数据库上，至少保证部分用户是可以正常使用的
  - for 2. 热点数据可以考虑设置永不过期
  - for 2. 提高数据库的容灾能力，分库分表，读写分离
  - for 2. 双缓存方式，数据库数据同步到缓存A和B，A设置缓存时间，B不设置缓存时间，如果A为空的时候读B，同时异步更新缓存，但是更新的时候需要同时更新两个缓存。

### 熔断

//todo


### ACID

在传统的关系型数据库中，常常用ACID性质来检验事务功能的可靠性和安全性

在redis中，事务总是具备原子性、一致性、隔离性，并且当redis运行在某种特定的持久化模式下，事务也具有耐久性。

#### 原子性

事务具有原子性指的是，数据库将事务中的多个操作当做一个整体来执行，服务器要么就执行事务中的所有操作，要么就一个操作也不执行。

redis的事务与传统的关系型数据库事务的最大区别在于，redis不支持事务回滚机制（rollback），即使事务队列中某个命令在执行期间出现错误，整个事务也会继续执行下去，知道将事务队列中的所有命令都执行完毕。

#### 一致性

事务具有一致性是指，如果数据库在执行事务前是一致的，那么在事务执行后，无论事务是否执行成功，数据库也应该是一致的。

“一致”指的是数据符合数据本身的定义和要求，没有包含非法或者无效的错误数据。

#### 隔离性

事务的隔离性是指，即使数据库中有多个事务并发的执行，各个事务之间也不会相互影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。

因为redis使用单线程方式来执行事务，并且服务器保证，在执行事务期间不会对事务进行中断，因此redis的事务总是以串行的方式运行，并且事务也总是具有隔离性的。

#### 耐久性

事务的耐久性是指，当一个事务执行完毕时，执行这个事务所得的结果已经被保存到永久存储介质上了，及时服务器在事务执行完毕之后停机，执行事务所得的结果也不会丢失。

## 参考

- redis设计与实现
- [什么是缓存雪崩、缓存击穿、缓存穿透？](https://zhuanlan.zhihu.com/p/346651831)
- [【实战问题】-- 缓存穿透，缓存击穿和缓存雪崩的区别以及解决方案](https://segmentfault.com/a/1190000039688578)