# GDT数据结构

## xv6项目中的gdt

```c
struct segdesc {
  uint lim_15_0 : 16;  // Low bits of segment limit
  uint base_15_0 : 16; // Low bits of segment base address
  uint base_23_16 : 8; // Middle bits of segment base address

  //STA_X|STA_R = 1010
  //STA_W = 0010
  //STS_T32A = 0x9 = 1001
  uint type : 4;       // Segment type (see STS_ constants)
  uint s : 1;          // 0 = system, 1 = application
  uint dpl : 2;        // Descriptor Privilege Level
  uint p : 1;          // Present

  uint lim_19_16 : 4;  // High bits of segment limit
  uint avl : 1;        // Unused (available for software use)
  uint rsv1 : 1;       // Reserved
  uint db : 1;         // 0 = 16-bit segment, 1 = 32-bit segment
  uint g : 1;          // Granularity: limit scaled by 4K when set

  uint base_31_24 : 8; // High bits of segment base address
};
```

示例1：bootasm.S或者entryother.S

```S
lgdt    gdtdesc
# ..
gdt:
  SEG_NULLASM                             # null seg
  SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # code seg
  SEG_ASM(STA_W, 0x0, 0xffffffff)         # data seg

gdtdesc:
  .word   (gdtdesc - gdt - 1)             # sizeof(gdt) - 1
  .long   gdt                             # address gdt
```

```c
#define SEG_ASM(type,base,lim)  \
        .word (((lim) >> 12) & 0xffff), \
            ((base) & 0xffff);      \
        .byte (((base) >> 16) & 0xff), \
            (0x90 | (type)),         \
            (0xC0 | (((lim) >> 28) & 0xf)), \
            (((base) >> 24) & 0xff)
```

示例2：vm.c和x86.h

```c
void seginit(void){
    //...
    //STA_X|STA_R = 1010
    //STA_W = 0010
    c = &cpus[cpuid()];
    c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
    c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
    c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
    c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
    lgdt(c->gdt, sizeof(c->gdt));
    //...
}

#define SEG(type, base, lim, dpl) (struct segdesc)    \
{ ((lim) >> 12) & 0xffff, \
    (uint)(base) & 0xffff,      \
  ((uint)(base) >> 16) & 0xff, \
  \
  type, \
  1, \
  dpl, \
  1,       \
  \
  (uint)(lim) >> 28, \
  0, 0, 1, 1, \
  \
  (uint)(base) >> 24 }
```

```c
void switchuvm(struct proc *p){
    //...
    //#define STS_T32A    0x9     // Available 32-bit TSS
    //STS_T32A = 0x9 = 1001
    mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
                            sizeof(mycpu()->ts)-1, 0);
    mycpu()->gdt[SEG_TSS].s = 0;
    //...
}

#define SEG16(type, base, lim, dpl) (struct segdesc)  \
{ (lim) & 0xffff, \
  (uint)(base) & 0xffff,              \
  ((uint)(base) >> 16) & 0xff, \
  \
  type, \
  1, \
  dpl, \
  1,       \
  \
  (uint)(lim) >> 16, \
  0, 0, 1, 0, \
  \
  (uint)(base) >> 24 }
```

```c
static inline void
lgdt(struct segdesc *p, int size)
{
  volatile ushort pd[3];

  pd[0] = size-1;
  pd[1] = (uint)p;
  pd[2] = (uint)p >> 16;

  asm volatile("lgdt (%0)" : : "r" (pd));
}
```

## gdt中的1，2，3，4，5分别是做什么的

在 xv6 操作系统（或一般的 x86 内核）中，GDT（全局描述符表，Global Descriptor Table） 中的各个段索引（如 1、2、3、4、5）通常对应不同的 内核和用户模式的代码段和数据段，以及 任务状态段（TSS）。以下是它们的具体作用：

GDT 结构

xv6 的 GDT 主要有以下 5 个重要的段选择子：

```c
#define SEG_KCODE 1  // 内核代码段
#define SEG_KDATA 2  // 内核数据段
#define SEG_UCODE 3  // 用户代码段
#define SEG_UDATA 4  // 用户数据段
#define SEG_TSS   5  // 任务状态段（TSS）
```

GDT 通常会有 一个空的第 0 号描述符（即索引 0 不使用），所以 1~5 是真正的段描述符。

各个 GDT 段的详细作用

| 段索引	| 选择子值（索引 × 8）	| 段名称	| 作用 |
|--|--|--|--|
| 0 |	0x00 |	空描述符 | 	必须为空，防止 NULL 指针错误 |
| 1 |	0x08 |	SEG_KCODE	| 内核代码段（ring 0，执行内核代码） |
| 2 |	0x10 |	SEG_KDATA	| 内核数据段（ring 0，存储内核数据） |
| 3 |	0x18 |	SEG_UCODE	| 用户代码段（ring 3，执行用户程序） |
| 4 |	0x20 |	SEG_UDATA	| 用户数据段（ring 3，存储用户数据） |
| 5 |	0x28 |	SEG_TSS	| 任务状态段（TSS），用于进程切换| 

详细解析各个段

1. SEG_KCODE（内核代码段，索引 1）

- 作用：运行 内核代码（Ring 0）。
- 特权级：0（最高权限），用于 CPU 运行 内核模式。
- 访问方式：CS（代码段寄存器）会被加载这个段选择子（0x08）。
- 权限控制：
    - 只能在 特权级 0 访问（内核模式）。
    - CPU 执行 jmp 0x08:地址 或 call 0x08:地址 进入该段。

2. SEG_KDATA（内核数据段，索引 2）
- 作用：存放 内核数据（Ring 0）。
- 特权级：0（最高权限）。
- 访问方式：DS、ES、SS（数据、附加、栈段寄存器）会加载这个段选择子（0x10）。
- 特点：
    - 存放内核变量、全局数据、堆栈等。
    - 只有特权级 0 的代码可以访问该段。

3. SEG_UCODE（用户代码段，索引 3）
- 作用：运行 用户代码（Ring 3）。
- 特权级：3（最低权限），用于 CPU 运行 用户模式。
- 访问方式：
    - CS（代码段寄存器）会加载这个段选择子（0x18）。
    - jmp 0x18:地址 或 call 0x18:地址 进入该段。
- 特点：
    - 运行用户进程（例如 shell、应用程序）。
    - 访问受限，不能直接访问内核内存。

4. SEG_UDATA（用户数据段，索引 4）
- 作用：存放 用户数据（Ring 3）。
- 特权级：3（最低权限）。
- 访问方式：
    - DS、ES、SS 会加载这个段选择子（0x20）。
    - mov %ds, 0x20 设置数据段寄存器。
- 特点：
    - 存放用户态进程的数据。
    - 受权限控制，不能直接访问 SEG_KDATA。

5. SEG_TSS（任务状态段，索引 5）
- 作用：存放 任务状态段（TSS, Task State Segment），用于进程/线程切换。
- 选择子：0x28（索引 5）。
- 特殊性：
    - TSS 不是普通的代码段或数据段，而是 CPU 在 进程切换时 读取的特殊段。
    - 记录 任务切换的寄存器状态（esp0、ss0 这些和内核栈有关）。
    - 发生中断时，CPU 需要知道内核栈在哪里，TSS 记录了 esp0（内核栈指针）。

总结

在 xv6 和其他 x86 操作系统中，GDT 结构主要用于内核与用户态之间的隔离：
1.	SEG_KCODE（内核代码段） -> 内核模式执行代码。
2.	SEG_KDATA（内核数据段） -> 存储内核数据。
3.	SEG_UCODE（用户代码段） -> 运行用户模式的应用程序代码。
4.	SEG_UDATA（用户数据段） -> 存储用户模式的数据。
5.	SEG_TSS（任务状态段） -> 记录任务切换时 CPU 需要的信息。

这些段在 任务切换、用户进程运行、中断处理 时起到了关键作用。