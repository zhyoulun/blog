# 逻辑地址和线性地址

在保护模式下的系统架构层面，处理器通过两个阶段的地址转换来得到物理地址：逻辑地址转换和线性地址空间分页。

即使以最小化的方式使用段机制，处理器地址空间中的每一个字节都通过逻辑地址访问。逻辑地址由一个16位的段选择器和一个32位的偏移量组成。段选择器用于标识字节所在的段，而偏移量则指定相对于段基地址的位置。

处理器将每一个逻辑地址转换为一个线性地址。线性地址是处理器线性地址空间中的一个32位地址。与物理地址空间类似，线性地址空间是一个平坦的（未分段的）2³²字节地址空间，地址范围从0到 FFFFFFFFH。线性地址空间包含为系统定义的所有段和系统表。

![](/static/images/2502/p005.png)

为了将逻辑地址转换为线性地址，处理器执行以下操作：

1. 使用段选择器中的偏移量定位全局描述符表（GDT）或局部描述符表（LDT）中的段描述符，并将其读取到处理器中。（此步骤仅在将新段选择器加载到段寄存器时需要执行。）
2. 检查段描述符以验证段的访问权限和范围，确保该段是可访问的，并且偏移量在段的限制范围内。
3. 将段描述符中的段基地址与偏移量相加，形成线性地址。

如果未使用分页，处理器会将线性地址直接映射为物理地址（即线性地址直接通过处理器的地址总线输出）。如果线性地址空间启用了分页，则会使用第二级地址转换将线性地址转换为物理地址。

## Segment Selectors

![](/static/images/2502/p006.png)

段选择器是用于标识段的一个16位标识符。它并不直接指向段，而是指向定义该段的段描述符。段选择器包含以下内容：

- 索引（Index，位3到15）：选择GDT或LDT中的8192个描述符之一。处理器将索引值乘以8（一个段描述符占用的字节数），然后将结果加到GDT或LDT的基地址上（分别由GDTR或LDTR寄存器提供）。
- TI（表指示符）标志（位2）：指定要使用的描述符表。将该标志清零选择GDT；将该标志置位选择当前的LDT。
- 请求特权级（Requested Privilege Level, RPL）：
（位0和位1）。指定选择符的特权级。特权级的范围可以从0到3，其中0是最高特权级。

处理器的全局描述符表（GDT）的第一个条目未被使用。指向GDT该条目的段选择符（即索引为0且TI标志设置为0的段选择符）被用作“空段选择符”。当加载空选择符到段寄存器（CS或SS寄存器除外）时，处理器不会生成异常。然而，当使用持有空选择符的段寄存器访问内存时，处理器会生成异常。

空选择符可用于初始化未使用的段寄存器。将空段选择符加载到CS或SS寄存器会导致生成一般保护异常（#GP）。

段选择符作为指针变量的一部分对应用程序可见，但选择符的值通常由链接编辑器或链接加载器分配或修改，而不是由应用程序修改。

## Segment Registers

![](/static/images/2502/p007.png)

为了减少地址转换时间和编码复杂性，处理器提供了寄存器来保存最多6个段选择符（参见上图）。每个段寄存器支持特定类型的内存引用（代码、堆栈或数据）。为了使几乎所有类型的程序能够执行，至少必须将代码段（CS）、数据段（DS）和堆栈段（SS）寄存器加载为有效的段选择符。处理器还提供了三个额外的数据段寄存器（ES、FS和GS），这些寄存器可用于使当前执行的程序（或任务）能够访问额外的数据段。

程序要访问某个段，该段的段选择符必须已加载到某个段寄存器中。因此，尽管系统可以定义数千个段，但只有6个段可以立即使用。其他段可以通过在程序执行期间将其段选择符加载到这些寄存器中来使其可用。

每个段寄存器都有一个“可见”部分和一个“隐藏”部分。（隐藏部分有时被称为“描述符缓存”或“影子寄存器”。）当段选择符被加载到段寄存器的可见部分时，处理器还会将段选择符所指向的段描述符中的基地址、段限长和访问控制信息加载到段寄存器的隐藏部分。缓存到段寄存器（可见和隐藏部分）中的信息使处理器能够在不额外占用总线周期的情况下转换地址，而无需从段描述符中读取基地址和限长。在多个处理器访问同一描述符表的系统中，当描述符表被修改时，软件有责任重新加载段寄存器。如果不这样做，在内存中的描述符被修改后，可能会使用段寄存器中缓存的旧段描述符。

提供了两种加载段寄存器的指令：

1. 直接加载指令：例如MOV、POP、LDS、LES、LSS、LGS和LFS指令。这些指令显式地引用段寄存器。
2. 隐式加载指令：例如远指针版本的CALL、JMP和RET指令，SYSENTER和SYSEXIT指令，以及IRET、INTn、INTO和INT3指令。这些指令在其操作过程中会附带改变CS寄存器（有时还包括其他段寄存器）的内容。

MOV指令也可以用于将段寄存器的可见部分存储到通用寄存器中。

## Segment Descriptors

段描述符是全局描述符表（GDT）或局部描述符表（LDT）中的一种数据结构，它为处理器提供了段的大小、位置以及访问控制和状态信息。段描述符通常由编译器、链接器、加载器或操作系统（或执行程序）创建，而不是由应用程序创建。下图展示了所有类型段描述符的通用描述符格式。

![](/static/images/2502/p008.png)

段描述符中的标志和字段如下：

### **段限长字段（Segment Limit Field）**
指定段的大小。处理器将两个段限长字段组合成一个 20 位的值。处理器根据 G（粒度）标志的设置，以两种方式解释段限长：
- **如果粒度标志为 0**：段大小可以从 1 字节到 1 MB，以字节为单位递增。
- **如果粒度标志为 1**：段大小可以从 4 KB 到 4 GB，以 4 KB 为单位递增。

处理器根据段是向上扩展段还是向下扩展段，以两种不同方式使用段限长：
- **向上扩展段**：逻辑地址中的偏移量范围从 0 到段限长。超过段限长的偏移量会触发一般保护异常（#GP）。
- **向下扩展段**：段限长的功能相反；偏移量范围从段限长到 FFFFFFFFH 或 FFFFH（取决于 B 标志的设置）。小于段限长的偏移量会触发一般保护异常。减小向下扩展段的段限长值会在段地址空间的底部（而非顶部）分配新内存。IA-32 架构的堆栈总是向下增长，因此这种机制非常适合可扩展堆栈。

---

### **基地址字段（Base Address Fields）**
定义段在 4 GB 线性地址空间中的起始位置（字节 0）。处理器将三个基地址字段组合成一个 32 位的值。段基地址应对齐到 16 字节边界。虽然 16 字节对齐不是必需的，但这种对齐方式可以通过将代码和数据对齐到 16 字节边界来最大化程序性能。

---

### **类型字段（Type Field）**
指示段或门的类型，并指定可以对段进行的访问类型以及段的增长方向。该字段的解释取决于描述符类型标志是指定应用程序（代码或数据）描述符还是系统描述符。类型字段的编码对于代码、数据和系统描述符是不同的（参见图 4-1）。有关如何使用该字段指定代码段和数据段类型的描述，请参见第 3.4.3.1 节“代码段和数据段描述符类型”。

---

### **S（描述符类型）标志**
指定段描述符是用于系统段（S 标志为 0）还是代码段或数据段（S 标志为 1）。

---

### **DPL（描述符特权级）字段**
指定段的特权级。特权级范围从 0 到 3，0 为最高特权级。DPL 用于控制对段的访问。有关 DPL 与执行代码段的当前特权级（CPL）以及段选择符的请求特权级（RPL）之间关系的描述，请参见第 4.5 节“特权级”。

---

### **P（段存在）标志**
指示段是否存在于内存中（1 表示存在，0 表示不存在）。如果该标志为 0，当指向该段描述符的段选择符被加载到段寄存器时，处理器会生成段不存在异常（#NP）。内存管理软件可以使用该标志来控制哪些段在给定时间实际加载到物理内存中。它为管理虚拟内存提供了除分页之外的另一种控制机制。

下图显示了段存在标志为 0 时段描述符的格式。当该标志为 0 时，操作系统或执行程序可以自由使用标记为“可用”的位置来存储自己的数据，例如有关缺失段位置的信息。

![](/static/images/2502/p009.png)

---

### **D/B（默认操作大小/默认堆栈指针大小和/或上界）标志**
根据段描述符是可执行代码段、向下扩展数据段还是堆栈段，执行不同的功能。（对于 32 位代码和数据段，该标志应始终设置为 1；对于 16 位代码和数据段，应设置为 0。）
- **可执行代码段**：该标志称为 D 标志，指示段中指令引用的有效地址和操作数的默认长度。如果该标志为 1，则假定为 32 位地址和 32 位或 8 位操作数；如果为 0，则假定为 16 位地址和 16 位或 8 位操作数。
  - 指令前缀 66H 可用于选择非默认的操作数大小，前缀 67H 可用于选择非默认的地址大小。
- **堆栈段（由 SS 寄存器指向的数据段）**：该标志称为 B（大）标志，指定用于隐式堆栈操作（如压栈、弹栈和调用）的堆栈指针大小。如果该标志为 1，则使用 32 位堆栈指针（存储在 ESP 寄存器中）；如果为 0，则使用 16 位堆栈指针（存储在 SP 寄存器中）。如果堆栈段被设置为向下扩展数据段（见下一段），B 标志还指定堆栈段的上界。
- **向下扩展数据段**：该标志称为 B 标志，指定段的上界。如果该标志为 1，上界为 FFFFFFFFH（4 GB）；如果为 0，上界为 FFFFH（64 KB）。

---

### **G（粒度）标志**
确定段限长字段的缩放比例。当粒度标志为 0 时，段限长以字节为单位解释；当粒度标志为 1 时，段限长以 4 KB 为单位解释。（该标志不影响基地址的粒度；基地址始终以字节为单位。）当粒度标志为 1 时，检查偏移量是否超出段限长时，偏移量的最低 12 位不会被测试。例如，当粒度标志为 1 时，段限长为 0 时，有效的偏移量范围为 0 到 4095。

---

### **可用和保留位**
段描述符的第二个双字的第 20 位可供系统软件使用；第 21 位是保留位，应始终设置为 0。

---

### 总结
段描述符中的字段和标志共同定义了段的大小、位置、访问权限和状态信息。这些信息使处理器能够有效地管理内存访问，并提供硬件级别的保护机制。

## CODE- AND DATA-SEGMENT DESCRIPTOR TYPES

![](/static/images/2502/p010.png)

当段描述符中的 **S（描述符类型）标志** 设置为 1 时，该描述符用于代码段或数据段。此时，类型字段的最高位（段描述符的第二个双字的第 11 位）决定描述符是用于数据段（0）还是代码段（1）。

---

### **数据段**
对于数据段，类型字段的低三位（第 8、9 和 10 位）被解释为：
- **A（访问位）**：指示段是否被访问过。
- **W（写使能位）**：指示段是否可写。
- **E（扩展方向位）**：指示段是向上扩展还是向下扩展。

数据段可以是只读或读/写段，具体取决于写使能位的设置。

#### **堆栈段**
堆栈段是一种必须为读/写的数据段。如果加载到 SS 寄存器的段选择符指向一个不可写的数据段，会触发一般保护异常（#GP）。如果堆栈段的大小需要动态调整，堆栈段可以是向下扩展的数据段（扩展方向位为 1）。在这种情况下，动态调整段限长会在堆栈底部增加空间。如果堆栈段的大小需要保持不变，堆栈段可以是向上扩展或向下扩展类型。

#### **访问位**
访问位指示自操作系统或执行程序上次清除该位以来，段是否被访问过。每当处理器将段的段选择符加载到段寄存器时，都会设置该位（假设包含段描述符的内存支持处理器写入）。该位会一直保持设置状态，直到显式清除。访问位可用于虚拟内存管理和调试。

---

### **代码段**
对于代码段，类型字段的低三位被解释为：
- **A（访问位）**：指示段是否被访问过。
- **R（读使能位）**：指示段是否可读。
- **C（一致位）**：指示段是否是一致代码段。

代码段可以是仅执行或执行/读段，具体取决于读使能位的设置。执行/读段可用于将常量或其他静态数据与指令代码一起存储在 ROM 中。在这种情况下，可以通过使用带有 CS 前缀覆盖的指令或将代码段的段选择符加载到数据段寄存器（DS、ES、FS 或 GS 寄存器）来从代码段读取数据。在保护模式下，代码段不可写。

代码段可以是一致或非一致段：
- **一致代码段**：将执行转移到更高特权级的一致代码段时，允许在当前特权级继续执行。
- **非一致代码段**：将执行转移到不同特权级的非一致代码段时，会触发一般保护异常（#GP），除非使用调用门或任务门（有关一致和非一致代码段的更多信息，请参见第 4.8.1 节“直接调用或跳转到代码段”）。

一些不需要访问受保护设施的系统实用程序（如除错或溢出异常的处理程序）可以加载到一致代码段中。需要防止低特权程序访问的实用程序应放置在非一致代码段中。

#### **注意**
无论目标段是一致还是非一致代码段，都无法通过调用或跳转将执行转移到更低特权级（数值上更高的特权级）的代码段。尝试此类执行转移会触发一般保护异常。

---

### **数据段的访问**
所有数据段都是非一致的，这意味着它们不能被更低特权级的程序或过程（在数值上更高特权级执行的代码）访问。然而，与代码段不同，数据段可以被更高特权级的程序或过程（在数值上更低特权级执行的代码）访问，而无需使用特殊的访问门。

---

### **ROM 中的段描述符**
如果 GDT 或 LDT 中的段描述符位于 ROM 中，当软件或处理器尝试更新（写入）基于 ROM 的段描述符时，处理器可能会进入无限循环。为避免此问题，应将 ROM 中所有段描述符的访问位设置为 1。此外，应删除任何尝试修改 ROM 中段描述符的操作系统或执行程序代码。

---

### 总结
- **S 标志**：区分代码段和数据段。
- **数据段**：通过类型字段的低三位控制访问权限和扩展方向。
- **代码段**：通过类型字段的低三位控制访问权限和一致性。
- **ROM 中的段描述符**：需要特别处理以避免无限循环。
