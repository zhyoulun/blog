# PRIVILEGE LEVEL CHECKING WHEN ACCESSING DATA SEGMENTS

![](/static/images/2502/p030.png)

![](/static/images/2502/p031.png)

要访问数据段中的操作数，数据段的段选择子必须加载到数据段寄存器（DS、ES、FS或GS）或栈段寄存器（SS）中。（段寄存器可以通过MOV、POP、LDS、LES、LFS、LGS和LSS指令加载。）在处理器将段选择子加载到段寄存器之前，它会通过比较当前运行程序或任务的特权级别（CPL）、段选择子的RPL以及段描述符的DPL来执行特权检查（参见图4-3）。如果DPL在数值上大于或等于CPL和RPL，处理器将段选择子加载到段寄存器中。否则，会生成一般保护故障，并且段寄存器不会被加载。

图4-4展示了四个过程（分别位于代码段A、B、C和D中），每个过程以不同的特权级别运行，并且每个过程都尝试访问同一个数据段。

- **代码段A中的过程**能够使用段选择子E1访问数据段E，因为代码段A的CPL和段选择子E1的RPL等于数据段E的DPL。
- **代码段B中的过程**能够使用段选择子E2访问数据段E，因为代码段A的CPL和段选择子E2的RPL在数值上都小于（特权更高）数据段E的DPL。代码段B的过程也可以使用段选择子E1访问数据段E。
- **代码段C中的过程**无法使用段选择子E3访问数据段E（虚线），因为代码段C的CPL和段选择子E3的RPL在数值上都大于（特权更低）数据段E的DPL。即使代码段C的过程使用段选择子E1或E2，使得RPL可接受，它仍然无法访问数据段E，因为其CPL特权不足。
- **代码段D中的过程**应该能够访问数据段E，因为代码段D的CPL在数值上小于数据段E的DPL。然而，段选择子E3的RPL（代码段D的过程用于访问数据段E）在数值上大于数据段E的DPL，因此不允许访问。如果代码段D的过程使用段选择子E1或E2访问数据段，则允许访问。

如前面的示例所示，程序或任务的可寻址域随着其CPL的变化而变化。当CPL为0时，可以访问所有特权级别的数据段；当CPL为1时，只能访问特权级别1到3的数据段；当CPL为3时，只能访问特权级别3的数据段。

段选择子的RPL始终可以覆盖程序或任务的可寻址域。如果使用得当，RPL可以防止较低特权的程序或过程意外（或故意）使用特权数据段的段选择子导致的问题。

需要注意的是，数据段的段选择子的RPL是受软件控制的。例如，以CPL为3运行的应用程序可以将数据段选择子的RPL设置为0。当RPL设置为0时，只有CPL检查（而不是RPL检查）才能提供保护，防止故意直接尝试违反数据段的特权级别安全性。为了防止这些类型的特权级别检查违规，程序或过程在从另一个过程接收到数据段选择子时可以检查访问权限（参见第4.10.4节“检查调用者访问权限（ARPL指令）”）。

## Accessing Data in Code Segments

在某些情况下，可能需要访问包含在代码段中的数据结构。以下是访问代码段中数据的可能方法：
将数据段寄存器加载为非符合、可读代码段的段选择子。
将数据段寄存器加载为符合、可读代码段的段选择子。
使用代码段覆盖前缀（CS）读取已经加载在 CS 寄存器中的可读代码段。
访问数据段的相同规则适用于方法 1。方法 2 始终有效，因为符合代码段的特权级别实际上与 CPL 相同，无论其 DPL 如何。方法 3 始终有效，因为由 CS 寄存器选择的代码段的 DPL 与 CPL 相同。