# PRIVILEGE LEVEL CHECKING WHEN TRANSFERRING PROGRAM CONTROL BETWEEN CODE SEGMENTS

为了将程序控制从一个代码段转移到另一个代码段，目标代码段的段选择子必须加载到代码段寄存器（CS）中。作为此加载过程的一部分，处理器会检查目标代码段的段描述符，并执行各种限长、类型和特权检查。如果这些检查成功，CS寄存器会被加载，程序控制转移到新的代码段，程序执行从EIP寄存器指向的指令开始。

程序控制转移通过JMP、CALL、RET、SYSENTER、SYSEXIT、INT n和IRET指令以及异常和中断机制来执行。异常、中断和IRET指令是特殊情况，将在第5章“中断和异常处理”中讨论。本章仅讨论JMP、CALL、RET、SYSENTER和SYSEXIT指令。

JMP或CALL指令可以通过以下四种方式引用另一个代码段：
1. **目标操作数包含目标代码段的段选择子**。
2. **目标操作数指向调用门描述符，调用门描述符包含目标代码段的段选择子**。
3. **目标操作数指向TSS，TSS包含目标代码段的段选择子**。
4. **目标操作数指向任务门，任务门指向TSS，TSS又包含目标代码段的段选择子**。

以下部分描述了前两种类型的引用。有关通过任务门和/或TSS转移程序控制的信息，请参见第6.3节“任务切换”。

SYSENTER和SYSEXIT指令是用于快速调用和从操作系统或执行程序过程返回的特殊指令。这些指令在第4.8.7节“使用SYSENTER和SYSEXIT指令快速调用系统过程”中简要讨论。

## Direct Calls or Jumps to Code Segments

![](/static/images/2502/p032.png)

JMP、CALL 和 RET 指令的近转移形式在当前代码段内转移程序控制权，因此不会执行特权级检查。而 JMP、CALL 和 RET 指令的远转移形式会将控制权转移到其他代码段，因此处理器会执行特权级检查。

当在不通过调用门的情况下将程序控制权转移到另一个代码段时，处理器会检查四种特权级和类型信息（参见图 4-5）：

- **CPL（当前特权级）**。在这里，CPL 是调用代码段的特权级，即包含进行调用或跳转过程的代码段的特权级。
  
- **目标代码段的段描述符的 DPL（描述符特权级）**。目标代码段包含被调用的过程。
  
- **目标代码段的段选择子的 RPL（请求特权级）**。
  
- **目标代码段的段描述符中的一致（C）标志**。该标志决定了该段是否是一致代码段（C 标志被设置）或非一致代码段（C 标志被清除）。（有关此标志的更多信息，请参见第 3.4.3.1 节“代码段和数据段描述符类型”。）

处理器用于检查 CPL、RPL 和 DPL 的规则取决于 C 标志的设置，如下文所述。

### ACCESSING NONCONFORMING CODE SEGMENTS

在访问非符合代码段时，调用过程的CPL必须与目标代码段的DPL相等；否则，处理器会生成一般保护异常（#GP）。

例如，在图4-6中，代码段C是一个非符合代码段。因此，代码段A中的过程可以调用代码段C中的过程（使用段选择子C1），因为它们处于相同的特权级别（代码段A的CPL等于代码段C的DPL）。然而，代码段B中的过程不能调用代码段C中的过程（使用段选择子C2或C1），因为这两个代码段处于不同的特权级别。

指向非符合代码段的段选择子的RPL对特权检查的影响有限。RPL在数值上必须小于或等于调用过程的CPL，才能成功进行控制转移。因此，在图4-6的示例中，段选择子C1和C2的RPL可以合法地设置为0、1或2，但不能设置为3。

当非符合代码段的段选择子加载到CS寄存器时，特权级别字段不会更改；也就是说，它仍然保持在CPL（即调用过程的特权级别）。即使段选择子的RPL与CPL不同，这一点也成立。

![](/static/images/2502/p033.png)

### ACCESSING CONFORMING CODE SEGMENTS


在访问一致代码段时，调用过程的 **CPL（当前特权级）** 可以在数值上等于或大于（特权级更低）目标代码段的 **DPL（描述符特权级）**；只有当 **CPL** 小于 **DPL** 时，处理器才会生成一般保护异常（#GP）。（如果目标代码段是一致代码段，则不会检查目标代码段的段选择子的 **RPL（请求特权级）**。）

在图 4-6 的示例中，代码段 D 是一个一致代码段。因此，代码段 A 和代码段 B 中的调用过程都可以访问代码段 D（分别使用段选择子 D1 或 D2），因为它们的 **CPL** 都大于或等于一致代码段的 **DPL**。对于一致代码段，**DPL** 表示调用过程能够成功调用该代码段所需的最低特权级数值。

（需要注意的是，段选择子 D1 和 D2 除了各自的 **RPL** 外完全相同。但由于访问一致代码段时不会检查 **RPL**，因此这两个段选择子基本上可以互换。）

当程序控制权转移到一致代码段时，**CPL** 不会改变，即使目标代码段的 **DPL** 小于 **CPL**。这是唯一一种 **CPL** 可能与当前代码段的 **DPL** 不同的情况。此外，由于 **CPL** 没有改变，因此不会发生堆栈切换。

一致代码段用于诸如数学库和异常处理程序等代码模块，这些模块支持应用程序但不需要访问受保护的系统设施。这些模块是操作系统或执行软件的一部分，但它们可以在数值上更高的特权级（特权级更低）执行。在切换到一致代码段时保持 **CPL** 为调用代码段的特权级，可以防止应用程序在一致代码段的特权级（**DPL**）下访问非一致代码段，从而防止其访问更高特权级的数据。

大多数代码段是非一致代码段。对于这些代码段，程序控制权只能转移到相同特权级的代码段，除非通过调用门进行转移，如下文所述。


## Gate Descriptors

为了提供对具有不同特权级别的代码段的受控访问，处理器提供了一组特殊的描述符，称为门描述符。门描述符有四种类型：

- **调用门**
- **陷阱门**
- **中断门**
- **任务门**

任务门用于任务切换，并在第6章“任务管理”中讨论。陷阱门和中断门是用于调用异常和中断处理程序的特殊类型的调用门。它们在第5章“中断和异常处理”中描述。本章仅涉及调用门。

## Call Gates

调用门（Call Gate）促进了程序控制权在不同特权级之间的受控转移。它们通常仅在使用特权级保护机制的操作系统或执行程序中使用。调用门还可用于在 16 位和 32 位代码段之间转移程序控制权，如第 17.4 节“混合大小代码段之间的控制权转移”所述。

图 4-7 展示了调用门描述符的格式。调用门描述符可以位于 GDT（全局描述符表）或 LDT（局部描述符表）中，但不能位于中断描述符表（IDT）中。它执行以下六项功能：

- 指定要访问的代码段。
- 定义指定代码段中过程的入口点。
- 指定调用者访问该过程所需的特权级。
- 如果发生堆栈切换，指定要在堆栈之间复制的可选参数的数量。
- 定义要压入目标堆栈的值的大小：16 位调用门强制 16 位压栈，32 位调用门强制 32 位压栈。
- 指定调用门描述符是否有效。

调用门中的段选择子字段指定要访问的代码段。偏移字段指定代码段中的入口点。此入口点通常是特定过程的第一条指令。**DPL** 字段表示调用门的特权级，即通过调用门访问选定过程所需的特权级。**P** 标志指示调用门描述符是否有效。（调用门指向的代码段的存在性由代码段描述符中的 **P** 标志指示。）参数计数字段指示如果发生堆栈切换，要从调用过程的堆栈复制到新堆栈的参数数量（参见第 4.8.5 节“堆栈切换”）。参数计数指定 16 位调用门的字数或 32 位调用门的双字数。

需要注意的是，调用门描述符中的 **P** 标志通常始终设置为 1。如果设置为 0，当程序尝试访问该描述符时会生成不存在（#NP）异常。操作系统可以将 **P** 标志用于特殊用途。例如，它可以用于跟踪调用门的使用次数。在这种情况下，**P** 标志最初设置为 0，从而触发不存在异常处理程序的陷阱。然后，异常处理程序递增计数器并将 **P** 标志设置为 1，以便从处理程序返回后，调用门描述符将变为有效。

![](/static/images/2502/p034.png)

## Accessing a Code Segment Through a Call Gate

要访问调用门，CALL或JMP指令的目标操作数中需要提供一个指向调用门的远指针。该指针的段选择子标识调用门（参见图4-8）；指针的偏移量是必需的，但处理器不会使用或检查它。（偏移量可以设置为任何值。）

当处理器访问调用门后，它会使用调用门中的段选择子来定位目标代码段的段描述符。（该段描述符可以在GDT或LDT中。）然后，它将代码段描述符中的基地址与调用门中的偏移量结合起来，形成代码段中过程入口点的线性地址。

如图4-9所示，通过调用门进行程序控制转移时，会使用四种不同的特权级别来检查其有效性：
- **CPL（当前特权级别）**。
- **调用门选择子的RPL（请求者特权级别）**。
- **调用门描述符的DPL（描述符特权级别）**。
- **目标代码段段描述符的DPL**。

同时还会检查目标代码段段描述符中的C标志（符合）。

![](/static/images/2502/p035.png)

![](/static/images/2502/p036.png)

特权检查规则根据控制转移是通过 **CALL** 指令还是 **JMP** 指令发起而有所不同，如表 4-1 所示。

![](/static/images/2502/p037.png)

调用门描述符的DPL字段指定了调用过程可以访问调用门的最高特权级别；也就是说，要访问调用门，调用过程的CPL必须小于或等于调用门的DPL。例如，在图4-12中，调用门A的DPL为3。因此，所有CPL（0到3）的调用过程都可以访问此调用门，包括代码段A、B和C中的调用过程。调用门B的DPL为2，因此只有CPL为0、1或2的调用过程可以访问调用门B，包括代码段B和C中的调用过程。虚线表示代码段A中的调用过程无法访问调用门B。

调用门段选择子的RPL必须满足与调用过程的CPL相同的测试；也就是说，RPL必须小于或等于调用门的DPL。在图4-12的示例中，代码段C中的调用过程可以使用门选择子B2或B1访问调用门B，但不能使用门选择子B3访问调用门B。

如果调用过程和调用门之间的特权检查成功，处理器随后会检查代码段描述符的DPL与调用过程的CPL。在这里，CALL和JMP指令的特权检查规则有所不同。只有CALL指令可以使用调用门将程序控制转移到更高特权（数值上更低特权级别）的非符合代码段；即，转移到DPL小于CPL的非符合代码段。JMP指令只能使用调用门将程序控制转移到DPL等于CPL的非符合代码段。CALL和JMP指令都可以将程序控制转移到更高特权的符合代码段；即，转移到DPL小于或等于CPL的符合代码段。

如果调用转移到更高特权（数值上更低特权级别）的非符合目标代码段，CPL会降低到目标代码段的DPL，并且会发生栈切换（参见第4.8.5节“栈切换”）。如果调用或跳转转移到更高特权的符合目标代码段，CPL不会改变，也不会发生栈切换。

调用门允许单个代码段具有可以在不同特权级别访问的过程。例如，位于代码段中的操作系统可能有一些既供操作系统使用又供应用程序使用的服务（例如处理字符I/O的过程）。可以为这些过程设置允许所有特权级别（0到3）访问的调用门。然后可以为其他仅供操作系统使用的操作系统服务（例如初始化设备驱动程序的过程）设置更高特权（DPL为0或1）的调用门。

![](/static/images/2502/p038.png)

## Stack Switching

每当使用调用门将程序控制转移到更高特权的非符合代码段时（即，当非符合目标代码段的DPL小于CPL时），处理器会自动切换到目标代码段特权级别的栈。这种栈切换是为了防止更高特权的过程因栈空间不足而崩溃。它还防止较低特权的过程通过共享栈（无论是意外还是故意）干扰更高特权的过程。

每个任务必须定义最多4个栈：一个用于应用程序代码（在特权级别3运行），以及用于使用的每个特权级别2、1和0的栈。（如果只使用两个特权级别[3和0]，则只需定义两个栈。）每个栈位于单独的段中，并通过段选择子和栈段中的偏移量（栈指针）来标识。

当执行特权级别3的代码时，特权级别3栈的段选择子和栈指针分别位于SS和ESP寄存器中，并在发生栈切换时自动存储在被调用过程的栈上。

特权级别0、1和2栈的指针存储在当前运行任务的TSS中（参见图6-2）。每个指针由一个段选择子和一个栈指针（加载到ESP寄存器中）组成。这些初始指针是严格只读的值。处理器在任务运行时不会更改它们。它们仅用于在调用更高特权级别（数值上更低特权级别）时创建新栈。当从被调用过程返回时，这些栈会被丢弃。下次调用该过程时，将使用初始栈指针创建一个新栈。（TSS没有为特权级别3指定栈，因为处理器不允许从以CPL为0、1或2运行的过程转移到以CPL为3运行的过程，除非是返回。）

操作系统负责为所有要使用的特权级别创建栈和栈段描述符，并将这些栈的初始指针加载到TSS中。每个栈必须是可读/写的（如其段描述符的类型字段所指定），并且必须包含足够的空间（如其限长字段所指定）以容纳以下内容：
- 调用过程的SS、ESP、CS和EIP寄存器的内容。
- 被调用过程所需的参数和临时变量。
- 当隐式调用异常或中断处理程序时，EFLAGS寄存器和错误代码。

栈需要足够的空间来容纳这些内容的多个帧，因为过程通常会调用其他过程，并且操作系统可能支持多个中断的嵌套。每个栈应足够大，以允许其特权级别下的最坏情况嵌套场景。

（如果操作系统不使用处理器的多任务机制，它仍然必须至少创建一个TSS用于与栈相关的目的。）

当通过调用门进行的过程调用导致特权级别更改时，处理器执行以下步骤以切换栈并在新特权级别开始执行被调用过程：
1. 使用目标代码段的DPL（新的CPL）从TSS中选择指向新栈的指针（段选择子和栈指针）。
2. 从当前TSS中读取要切换到的栈的段选择子和栈指针。在读取栈段选择子、栈指针或栈段描述符时检测到的任何限长违规都会导致生成无效TSS（#TS）异常。
3. 检查栈段描述符的特权和类型，如果检测到违规，则生成无效TSS（#TS）异常。
4. 临时保存SS和ESP寄存器的当前值。
5. 将新栈的段选择子和栈指针加载到SS和ESP寄存器中。
6. 将临时保存的SS和ESP寄存器的值（用于调用过程）推入新栈（参见图4-11）。
7. 从调用过程的栈中复制调用门参数计数字段中指定的参数数量到新栈。如果计数为0，则不复制参数。
8. 将返回指令指针（CS和EIP寄存器的当前内容）推入新栈。
9. 将新代码段的段选择子和新指令指针从调用门加载到CS和EIP寄存器中，并开始执行被调用过程。

有关处理器在通过调用门进行远调用时执行的特权级别检查和其他保护检查的详细描述，请参见《IA-32 Intel架构软件开发手册》第2卷第3章“指令集参考”中的CALL指令描述。

调用门中的参数计数字段指定处理器应从调用过程的栈复制到被调用过程栈的数据项数量（最多31个）。如果需要传递超过31个数据项，其中一个参数可以是指向数据结构的指针，或者可以使用保存的SS和ESP寄存器内容访问旧栈空间中的参数。传递给被调用过程的数据项的大小取决于调用门的大小，如第4.8.3节“调用门”所述。

![](/static/images/2502/p039.png)

## Returning from a Called Procedure

**RET指令**可用于执行近返回、同特权级别的远返回以及不同特权级别的远返回。该指令旨在执行从通过CALL指令调用的过程的返回。它不支持从JMP指令返回，因为JMP指令不会在栈上保存返回指令指针。

**近返回**仅在当前代码段内转移程序控制；因此，处理器仅执行限长检查。当处理器将返回指令指针从栈弹出到EIP寄存器时，它会检查指针是否超出当前代码段的限长。

**同特权级别的远返回**时，处理器从栈中弹出要返回的代码段的段选择子和返回指令指针。在正常情况下，这些指针应该是有效的，因为它们是由CALL指令推入栈的。然而，处理器会执行特权检查，以检测当前过程可能更改了指针或未能正确维护栈的情况。

**需要特权级别更改的远返回**仅在返回到较低特权级别时允许（即，返回代码段的DPL在数值上大于CPL）。处理器使用为调用过程保存的CS寄存器值中的RPL字段（参见图4-11）来确定是否需要返回到数值上更高的特权级别。如果RPL在数值上大于（特权较低）CPL，则会发生跨特权级别的返回。

处理器在执行远返回到调用过程时执行以下步骤（有关返回前后栈内容的图示，请参见《IA-32 Intel架构软件开发手册》第1卷中的图6-2和图6-4）：

1. 检查保存的CS寄存器值的RPL字段，以确定返回时是否需要更改特权级别。
2. 使用被调用过程栈上的值加载CS和EIP寄存器。（对代码段描述符和代码段选择子的RPL执行类型和特权级别检查。）
3. （如果RET指令包含参数计数操作数且返回需要特权级别更改。）将参数计数（从RET指令中获取的字节数）添加到当前ESP寄存器值（在弹出CS和EIP值之后），以跳过被调用过程栈上的参数。ESP寄存器中的结果值指向调用过程栈的保存的SS和ESP值。（注意，RET指令中的字节计数必须与调用过程在原始调用时引用的调用门中的参数计数乘以参数大小相匹配。）
4. （如果返回需要特权级别更改。）使用保存的SS和ESP值加载SS和ESP寄存器，并切换回调用过程的栈。被调用过程栈的SS和ESP值被丢弃。在加载栈段选择子或栈指针时检测到的任何限长违规都会导致生成一般保护异常（#GP）。还会检查新栈段描述符的类型和特权违规。
5. （如果RET指令包含参数计数操作数。）将参数计数（从RET指令中获取的字节数）添加到当前ESP寄存器值，以跳过调用过程栈上的参数。生成的ESP值不会与栈段的限长进行检查。如果ESP值超出限长，该事实将在下一次栈操作时被识别。
6. （如果返回需要特权级别更改。）检查DS、ES、FS和GS段寄存器的内容。如果这些寄存器中的任何一个引用其DPL小于新CPL的段（不包括符合代码段），则段寄存器将加载为空段选择子。

有关处理器在远返回时执行的特权级别检查和其他保护检查的详细描述，请参见《IA-32 Intel架构软件开发手册》第2卷第3章“指令集参考”中的RET指令描述。

## Performing Fast Calls to System Procedures with the SYSENTER and SYSEXIT Instructions

**SYSENTER** 和 **SYSEXIT** 指令是在 Pentium II 处理器中引入 IA-32 架构的，目的是为调用操作系统或执行程序过程提供一种快速（低开销）的机制。**SYSENTER** 指令旨在供运行在特权级 3 的用户代码使用，以访问运行在特权级 0 的操作系统或执行程序过程。**SYSEXIT** 指令旨在供特权级 0 的操作系统或执行程序过程使用，以快速返回到特权级 3 的用户代码。**SYSENTER** 指令可以从特权级 3、2 或 1 执行；而 **SYSEXIT** 指令只能从特权级 0 执行。

**SYSENTER** 和 **SYSEXIT** 指令是配套指令，但它们并不构成一个调用/返回对，因为 **SYSENTER** 指令不会保存任何状态信息供 **SYSEXIT** 指令在返回时使用。

这些指令的目标指令和堆栈指针不是通过指令操作数指定的，而是通过输入到多个 MSR（模型特定寄存器）和通用寄存器中的参数指定的。对于 **SYSENTER** 指令，处理器从以下来源获取特权级 0 的目标指令和堆栈指针：

- **目标代码段**：从 **SYSENTER_CS_MSR** 中读取。
- **目标指令**：从 **SYSENTER_EIP_MSR** 中读取。
- **堆栈段**：通过将 **SYSENTER_CS_MSR** 中的值加 8 计算得出。
- **堆栈指针**：从 **SYSENTER_ESP_MSR** 中读取。

对于 **SYSEXIT** 指令，特权级 3 的目标指令和堆栈指针按以下方式指定：

- **目标代码段**：通过将 **SYSENTER_CS_MSR** 中的值加 16 计算得出。
- **目标指令**：从 **EDX** 寄存器中读取。
- **堆栈段**：通过将 **SYSENTER_CS_MSR** 中的值加 24 计算得出。
- **堆栈指针**：从 **ECX** 寄存器中读取。

**SYSENTER** 和 **SYSEXIT** 指令执行“快速”调用和返回，因为它们在执行 **SYSENTER** 指令时将处理器强制进入预定义的特权级 0 状态，而在执行 **SYSEXIT** 指令时将处理器强制进入预定义的特权级 3 状态。通过强制预定义且一致的处理器状态，通常执行远调用到其他特权级所需的大量特权检查被大大减少。此外，通过在 MSR 和通用寄存器中预定义目标上下文状态，除了获取目标代码外，所有内存访问都被消除。

任何需要保存的额外状态（以允许返回到调用过程）必须由调用过程显式保存，或通过编程约定预定义。