# POINTER VALIDATION

在保护模式下操作时，处理器会验证所有指针，以强制执行段之间的保护并维护特权级别之间的隔离。指针验证包括以下检查：

1. **检查访问权限**，以确定段类型是否与其用途兼容。
2. **检查读/写权限**。
3. **检查指针偏移量是否超出段限长**。
4. **检查指针提供者是否被允许访问该段**。
5. **检查偏移量对齐**。

处理器在指令执行期间自动执行第一、第二和第三项检查。软件必须通过发出ARPL指令显式请求第四项检查。第五项检查（偏移量对齐）在特权级别3下自动执行，如果对齐检查已启用。偏移量对齐不会影响特权级别的隔离。

## Checking Access Rights (LAR Instruction)

当处理器使用远指针访问段时，它会检查远指针所指向的段描述符的访问权限。此检查用于确定段描述符的类型和特权级（DPL）是否与要执行的操作兼容。例如，在保护模式下进行远调用时，段描述符的类型必须是以下之一：一致代码段、非一致代码段、调用门、任务门或任务状态段（TSS）。然后，如果调用的是非一致代码段，代码段的 DPL 必须等于当前特权级（CPL），并且代码段的段选择符的请求特权级（RPL）必须小于或等于 DPL。如果发现类型或特权级不兼容，则会生成相应的异常。

为了防止生成类型不兼容异常，软件可以使用 **LAR（加载访问权限）指令** 检查段描述符的访问权限。LAR 指令指定要检查访问权限的段描述符的段选择符以及目标寄存器。该指令执行以下操作：
1. 检查段选择符是否为空。
2. 检查段选择符是否指向描述符表（GDT 或 LDT）范围内的段描述符。
3. 检查段描述符是否为代码段、数据段、LDT、调用门、任务门或 TSS 段描述符类型。
4. 如果段不是一致代码段，则检查段描述符在当前特权级（CPL）下是否可见（即段选择符的 CPL 和 RPL 是否小于或等于 DPL）。
5. 如果特权级和类型检查通过，则将段描述符的第二个双字加载到目标寄存器中（掩码值为 00FXFF00H，其中 X 表示对应的 4 位未定义），并设置 EFLAGS 寄存器中的 ZF 标志。如果段选择符在当前特权级下不可见，或者类型对 LAR 指令无效，则指令不会修改目标寄存器，并清除 ZF 标志。

一旦访问权限信息加载到目标寄存器中，软件可以对其进行额外的检查。

## Checking Read/Write Rights (VERR and VERW Instructions)

当处理器访问任何代码或数据段时，它会检查分配给该段的读/写权限，以验证所请求的读或写操作是否被允许。软件可以使用 **VERR**（验证读取）和 **VERW**（验证写入）指令来检查读/写权限。这两条指令都指定了要检查的段的段选择子。然后，指令执行以下操作：

1. 检查段选择子是否为空。
2. 检查段选择子是否指向位于描述符表（GDT 或 LDT）限制范围内的段描述符。
3. 检查段描述符是否为代码段或数据段描述符类型。
4. 如果段不是一致代码段，则检查段描述符在当前特权级（CPL）下是否可见（即段选择子的 **CPL** 和 **RPL** 是否小于或等于 **DPL**）。
5. 检查段是否可读（对于 **VERR** 指令）或可写（对于 **VERW** 指令）。

如果段在当前特权级下可见且可读，**VERR** 指令会设置 **EFLAGS** 寄存器中的 **ZF** 标志；如果段在当前特权级下可见且可写，**VERW** 指令会设置 **ZF** 标志。（代码段永远不可写。）如果任何检查失败，**ZF** 标志会被清除。

## Checking That the Pointer Offset Is Within Limits (LSL Instruction)

当处理器访问任何段时，它会执行限长检查，以确保偏移量在段的限长范围内。软件可以使用 **LSL（加载段限长）指令** 执行此限长检查。与 LAR 指令类似，LSL 指令指定要检查限长的段描述符的段选择符以及目标寄存器。该指令执行以下操作：
1. 检查段选择符是否为空。
2. 检查段选择符是否指向描述符表（GDT 或 LDT）范围内的段描述符。
3. 检查段描述符是否为代码段、数据段、LDT 或 TSS 段描述符类型。
4. 如果段不是一致代码段，则检查段描述符在当前特权级（CPL）下是否可见（即段选择符的 CPL 和 RPL 是否小于或等于 DPL）。
5. 如果特权级和类型检查通过，则将未解码的限长（根据段描述符中 G 标志的设置进行缩放后的限长）加载到目标寄存器中，并设置 EFLAGS 寄存器中的 ZF 标志。如果段选择符在当前特权级下不可见，或者类型对 LSL 指令无效，则指令不会修改目标寄存器，并清除 ZF 标志。

一旦限长加载到目标寄存器中，软件可以将其与指针的偏移量进行比较。

## Checking Caller Access Privileges (ARPL Instruction)

![](/static/images/2502/p040.png)

段选择子的请求者特权级（**RPL**）字段旨在将调用过程（调用过程的 **CPL**）的特权级传递给被调用过程。被调用过程随后使用 **RPL** 来确定是否允许访问某个段。**RPL** 被称为将被调用过程的特权级“削弱”到 **RPL** 所代表的特权级。

操作系统过程通常使用 **RPL** 来防止特权较低的应用程序访问位于更高特权段中的数据。当操作系统过程（被调用过程）从应用程序（调用过程）接收到一个段选择子时，它会将段选择子的 **RPL** 设置为调用过程的特权级。然后，当操作系统使用该段选择子访问其关联的段时，处理器会使用调用过程的特权级（存储在 **RPL** 中）而不是操作系统过程的数值上更低的特权级（**CPL**）来执行特权检查。因此，**RPL** 确保操作系统不会代表应用程序访问某个段，除非该应用程序本身有权访问该段。

图 4-12 展示了处理器如何使用 **RPL** 字段的示例。在此示例中，一个应用程序（位于代码段 A 中）拥有一个指向特权数据结构（即位于特权级 0 的数据段 D 中的数据结构）的段选择子（段选择子 D1）。

该应用程序无法访问数据段 D，因为它没有足够的特权，但操作系统（位于代码段 C 中）可以访问。因此，为了尝试访问数据段 D，应用程序执行对操作系统的调用，并将段选择子 D1 作为堆栈上的参数传递给操作系统。在传递段选择子之前，（行为良好的）应用程序将段选择子的 **RPL** 设置为其当前特权级（在此示例中为 3）。如果操作系统尝试使用段选择子 D1 访问数据段 D，处理器会比较 **CPL**（在调用后现在为 0）、段选择子 D1 的 **RPL** 和数据段 D 的 **DPL**（为 0）。由于 **RPL** 大于 **DPL**，因此对数据段 D 的访问被拒绝。处理器的保护机制因此保护数据段 D 不被操作系统访问，因为应用程序的特权级（由段选择子 B 的 **RPL** 表示）大于数据段 D 的 **DPL**。

现在假设应用程序没有将段选择子的 **RPL** 设置为 3，而是将其设置为 0（段选择子 D2）。操作系统现在可以访问数据段 D，因为其 **CPL** 和段选择子 D2 的 **RPL** 都等于数据段 D 的 **DPL**。

由于应用程序能够将段选择子的 **RPL** 更改为任何值，它可能利用数值上更低特权级的过程来访问受保护的数据结构。这种降低段选择子 **RPL** 的能力会破坏处理器的保护机制。

由于被调用过程无法依赖调用过程正确设置 **RPL**，因此从数值上更高特权级过程接收段选择子的操作系统过程（在数值上更低特权级执行）需要测试段选择子的 **RPL**，以确定其是否处于适当的级别。为此提供了 **ARPL**（调整请求特权级）指令。该指令将一个段选择子的 **RPL** 调整为与另一个段选择子的 **RPL** 匹配。

图 4-12 中的示例演示了 **ARPL** 指令的预期用途。当操作系统从应用程序接收到段选择子 D2 时，它使用 **ARPL** 指令将段选择子的 **RPL** 与应用程序的特权级（由推送到堆栈上的代码段选择子表示）进行比较。如果 **RPL** 小于应用程序的特权级，**ARPL** 指令会将段选择子的 **RPL** 更改为与应用程序的特权级匹配（段选择子 D1）。因此，使用该指令可以防止数值上更高特权级的过程通过降低段选择子的 **RPL** 来访问数值上更低特权级（更高特权）的段。

需要注意的是，应用程序的特权级可以通过读取应用程序代码段的段选择子的 **RPL** 字段来确定。该段选择子作为调用操作系统的一部分存储在堆栈中。操作系统可以将段选择子从堆栈复制到寄存器中，用作 **ARPL** 指令的操作数。

## Checking Alignment

当 CPL 为 3 时，可以通过设置 CR0 寄存器中的 AM 标志和 EFLAGS 寄存器中的 AC 标志来检查内存引用的对齐情况。未对齐的内存引用会生成对齐异常（#AC）。当处理器在特权级 0、1 或 2 下运行时，不会生成对齐异常。有关启用对齐检查时的对齐要求，请参见表 5-6。
