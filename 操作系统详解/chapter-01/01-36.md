# PAGE-LEVEL PROTECTION

页级保护可以单独使用，也可以与分段保护结合使用。当页级保护与平坦内存模型一起使用时，它允许保护内核代码和数据（操作系统或执行程序）免受用户代码和数据（应用程序）的访问。它还可以保护包含代码的页面不被写入。当分段保护和页级保护结合使用时，页级的读/写保护可以在段内提供更细粒度的保护。

与分段保护类似，页级保护在每次内存引用时都会进行检查，以确保满足保护要求。所有检查都在内存周期开始之前进行，任何违规行为都会阻止内存周期的启动，并导致生成页错误异常（#PF）。由于检查与地址转换并行执行，因此不会影响性能。

处理器执行两种页级保护检查：
- **可寻址域的限制**（内核模式和用户模式）。
- **页面类型**（只读或读/写）。

违反其中任何一种检查都会导致生成页错误异常。有关页错误异常机制的说明，请参见第 5 章“中断 14——页错误异常（#PF）”。本章描述了导致页错误异常的保护违规行为。


## Page-Protection Flags

页面的保护信息包含在页目录项或页表项的两个标志中（参见图 3-14）：读 / 写标志（第 1 位）和用户 / 内核标志（第 2 位）。保护检查适用于一级和二级页表（即页目录和页表）。

## Restricting Addressable Domain

页级保护机制允许基于两种特权级别限制对页面的访问：
- **内核模式（U/S 标志为 0）**——（最高特权）用于操作系统或执行程序、其他系统软件（如设备驱动程序）以及受保护的系统数据（如页表）。
- **用户模式（U/S 标志为 1）**——（最低特权）用于应用程序代码和数据。

段特权级别与页特权级别的映射如下：如果处理器当前以 **CPL** 0、1 或 2 运行，则处于内核模式；如果以 **CPL** 3 运行，则处于用户模式。当处理器处于内核模式时，它可以访问所有页面；而在用户模式时，它只能访问用户级页面。（请注意，控制寄存器 **CR0** 中的 **WP** 标志会修改内核权限，如第 4.11.3 节“页面类型”所述。）

需要注意的是，要使用页级保护机制，代码段和数据段必须至少设置为两个基于段的特权级别：级别 0 用于内核代码和数据段，级别 3 用于用户代码和数据段。（在此模型中，堆栈放置在数据段中。）为了尽量减少段的使用，可以采用平坦内存模型（参见第 3.2.1 节“基本平坦模型”）。

在这种模型中，用户和内核的代码段和数据段都从线性地址空间的地址零开始，并相互重叠。通过这种安排，操作系统代码（在内核级别运行）和应用程序代码（在用户级别运行）可以像没有段一样执行。操作系统与应用程序代码和数据之间的保护由处理器的页级保护机制提供。

## Page Type

页级保护机制识别两种页面类型：
- **只读访问（R/W 标志为 0）**。
- **读/写访问（R/W 标志为 1）**。

当处理器处于内核模式且寄存器 **CR0** 中的 **WP** 标志为清除状态（复位初始化后的状态）时，所有页面既可读又可写（忽略写保护）。当处理器处于用户模式时，它只能写入具有读/写访问权限的用户模式页面。用户模式页面无论是读/写还是只读，都是可读的；而内核模式页面在用户模式下既不可读也不可写。任何违反保护规则的尝试都会生成页错误异常。

P6 系列、Pentium 和 Intel486 处理器允许用户模式页面针对内核模式访问进行写保护。将寄存器 **CR0** 中的 **WP** 标志设置为 1，可以使内核模式对用户模式的写保护页面敏感。这种内核写保护功能对于实现某些操作系统（如 UNIX*）用于任务创建（也称为分叉或派生）的“写时复制”策略非常有用。当创建新任务时，可以复制父任务的整个地址空间。这为子任务提供了父任务段和页面的完整副本。另一种写时复制策略通过将子任务的段和页面映射到父任务使用的相同段和页面来节省内存空间和时间。只有当其中一个任务尝试写入页面时，才会创建页面的私有副本。通过使用 **WP** 标志并将共享页面标记为只读，内核可以检测到尝试写入用户级页面的行为，并在此时复制页面。

## Combining Protection of Both Levels of Page Tables

对于任何一个页面，其页目录项（一级页表）的保护属性可能与其页表项（二级页表）的保护属性不同。处理器会检查页目录项和页表项中的页面保护。表 4-2 展示了当 **WP** 标志为清除状态时，不同保护属性组合所提供的保护。

## Overrides to Page Protection

以下类型的内存访问会被视为特权级 0 访问进行检查，无论处理器当前运行的 **CPL** 是什么：
- 访问 GDT、LDT 或 IDT 中的段描述符。
- 在发生特权级变化的跨特权级调用或调用异常或中断处理程序期间，访问内部特权级的堆栈。

