vm.c 虚拟内存管理

vm.c 文件主要用于 虚拟内存管理，包括内存分页、页表管理、内存分配、虚拟内存到物理内存的映射等操作。它主要处理与 内存管理 相关的工作，涉及的功能通常包括：

- 页面分配和映射：为进程分配虚拟内存页，并将这些虚拟页映射到物理内存或交换空间。
- 页面管理：管理页面的加载、交换等操作。
- 内存访问控制：通过页表等结构管理不同进程的虚拟地址空间，确保每个进程只能访问它自己的内存区域。
- 交换（swapping）：当物理内存不够时，可能将某些页面交换到硬盘上。

vm.c 中的关键函数：


1.	seginit()
- 设置 CPU 的内核段描述符。该函数初始化每个 CPU 的全局描述符表 (GDT)，为内核和用户代码、数据区分设置不同的段。

2.	walkpgdir()
- 返回与虚拟地址 va 对应的页表项 (PTE)。如果页表项不存在且 alloc 参数非零，则分配新的页表页并初始化它。

3.	mappages()
- 为指定的虚拟地址范围 (从 va 到 va + size) 创建相应的物理地址映射，并将其映射到页表中。根据需要指定页表项的权限 (如读、写、用户权限等)。

4.	setupkvm()
- 初始化一个新的页表并进行内核的内存映射。这会将内核所需的内存区域映射到新页表中，涵盖内核代码、数据、I/O 空间等。

5.	kvmalloc()
- 为内核创建并初始化一个新的页表，并通过 switchkvm() 将硬件的页表寄存器切换到新的内核页表。

6.	switchkvm()
- 切换到内核的页表，通常在没有进程运行时使用。

7.	switchuvm()
- 切换到指定进程的用户空间页表。该函数会根据进程的页表和 TSS (任务状态段) 设置切换到该进程的用户地址空间。

8.	inituvm()
- 初始化一个新的进程的用户空间，将初始代码和数据加载到内存中，并在页表中建立对应的映射。

9.	loaduvm()
- 将程序段从磁盘 (通过 inode) 加载到虚拟地址空间中。确保加载时页表中的映射是正确的。

10.	allocuvm()
- 为进程扩展其用户空间（从 oldsz 扩展到 newsz），并为新的虚拟地址分配物理内存。

11.	deallocuvm()
- 将进程的用户空间缩小（从 oldsz 缩小到 newsz），并释放不再使用的物理内存。

12.	freevm()
- 释放进程的页表和与之关联的物理内存。

13.	clearpteu()
- 清除指定虚拟地址上的 PTE_U 位，使该页面不再对用户可访问，通常用于用户栈的底部，防止栈溢出访问内核空间。

14.	copyuvm()
- 创建一个进程页表的副本，并将父进程的内存内容复制到子进程的内存空间中。

15.	uva2ka()
- 将用户空间的虚拟地址转换为内核空间的虚拟地址，如果该地址不可访问或不属于用户空间，返回 0。

16.	copyout()
- 从内存缓冲区 p 向用户地址 va 复制数据，确保操作只对用户空间的页面有效。