```c
switchuvm(p);
swtch(&(c->scheduler), p->context);
switchkvm();
```

进程调度为什么是这个顺序，可以调整吗？




1.	switchuvm(p);
    - 该函数的作用是切换到进程 p 的用户虚拟内存（user virtual memory）。当进程切换时，操作系统需要确保当前进程的内存空间和地址映射（page table）被正确加载，因为每个进程可能有不同的虚拟内存空间。switchuvm(p) 确保在进程调度前，进程 p 的用户空间内存映射被加载到 CPU 中，以便程序执行。
2.	swtch(&(c->scheduler), p->context);
    - 这一部分是上下文切换的核心。swtch 函数将当前 CPU 的执行状态（即寄存器值等）保存到 p->context 中，然后恢复 c->scheduler 的上下文，意味着调度器的上下文被加载并执行。换句话说，调度器接管 CPU 执行。
    - 这个操作的目标是：在进程调度之前，保存当前进程的上下文，以便稍后可以恢复执行；同时，切换到调度器上下文（调度器用于决定哪个进程接下来会运行）。
3.	switchkvm();
    - switchkvm() 是切换到内核虚拟内存的操作。当控制权从用户进程切换到内核模式时，操作系统需要加载内核地址空间，因为内核有自己的内存区域。这个步骤保证内核代码（如调度器、系统调用处理等）能够在正确的地址空间中执行。


这个顺序保证了在调度过程中的几个关键步骤：

1.	switchuvm(p) 必须在上下文切换前执行，因为它确保在切换进程时，CPU 会使用正确的用户空间内存（即切换到目标进程 p 的虚拟内存）。
2.	swtch(&(c->scheduler), p->context) 是上下文切换的核心，保存当前进程的状态（即当前进程的寄存器等），并恢复调度器的状态。它是在 switchuvm 之后执行的，因为调度器需要在切换内存环境后决定调度哪个进程。
3.	switchkvm() 必须在切换到调度器上下文后执行，因为调度器代码通常运行在内核模式下，内核模式下需要使用内核虚拟内存。