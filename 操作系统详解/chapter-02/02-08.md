任务状态段（TSS, Task State Segment）

TSS（Task State Segment，任务状态段）是 x86 保护模式 下用于 进程/任务切换 的数据结构，它存储了与任务相关的各种状态信息，例如 CPU 寄存器、I/O 许可位图、栈指针等。

1. 为什么需要 TSS？

在 早期 x86 体系结构（如 80386）的设计中，任务切换（Task Switching）是由硬件完成的，CPU 通过 ljmp 到不同任务的 TSS 描述符来进行任务切换。在现代操作系统（如 Linux）中，任务切换 主要由软件完成，但 TSS 仍然用于存储 CPU 运行不同特权级（Ring 0 ~ Ring 3）时的栈指针。

2. TSS 结构

TSS 是一个特殊的数据结构，存放在 GDT（全局描述符表） 中，它的结构如下：

|字节偏移|	字段名称|	作用 |
|--|--|--|
| 0x00-0x03	| Previous TSS	|旧任务的 TSS 指针（硬件任务切换用，现代 OS 不使用） |
| 0x04-0x07	| ESP0 |	特权级 0 的栈指针（进程切换到内核时使用） |
| 0x08-0x0B	| SS0 |	特权级 0 的栈段选择子 |
| 0x0C-0x0F	| ESP1 |	特权级 1 的栈指针（通常未使用） |
| 0x10-0x13	| SS1 |	特权级 1 的栈段（通常未使用） |
| 0x14-0x17	| ESP2 |	特权级 2 的栈指针（通常未使用） |
| 0x18-0x1B	| SS2 |	特权级 2 的栈段（通常未使用） |
| 0x1C-0x1F	| CR3 |	任务的页目录基地址（虚拟地址翻译） |
| 0x20-0x23	| EIP |	任务的指令指针 |
| 0x24-0x27	| EFLAGS |	任务的标志寄存器 |
| 0x28-0x2B	| EAX |	任务的 EAX |
| 0x2C-0x2F	| ECX |	任务的 ECX |
| 0x30-0x33	| EDX |	任务的 EDX |
| 0x34-0x37	| EBX |	任务的 EBX |
| 0x38-0x3B	| ESP |	任务的 ESP |
| 0x3C-0x3F	| EBP |	任务的 EBP |
| 0x40-0x43	| ESI |	任务的 ESI |
| 0x44-0x47	| EDI |	任务的 EDI |
| 0x48-0x4B	| ES |	任务的 ES |
| 0x4C-0x4F	| CS |	任务的 CS |
| 0x50-0x53	| SS |	任务的 SS |
| 0x54-0x57	| DS |	任务的 DS |
| 0x58-0x5B	| FS |	任务的 FS |
| 0x5C-0x5F	| GS |	任务的 GS |
| 0x60-0x63	| LDT Selector |	任务的 LDT 选择子（局部描述符表） |
| 0x64-0x67	| I/O Map Base |	I/O 许可位图的偏移（用于控制任务对 I/O 端口的访问） |


3. TSS 在| 现代操作系统中的作用

虽然 现代操作系统（如 Linux）不会使用硬件任务切换，但 TSS 仍然在 CPU 进入内核模式（Ring 0）时用于切换栈。关键作用如下：

1.	特权级 3 -> 特权级 0 切换时，CPU 需要使用 TSS 中的 ESP0
- 当用户态（Ring 3）代码执行系统调用（syscall）或发生中断时，CPU 会自动使用 TSS.ESP0 作为新的 内核栈指针。
- 这样可以防止用户态程序影响内核态的栈，保证安全性。

2.	I/O 许可位图（I/O Permission Bitmap）
- TSS 允许操作系统限制进程对 I/O 端口的访问。
- 这在虚拟化和安全场景（如 VMM）中很有用。

4. TSS 在 Linux 中

在 Linux 内核 中：
- 每个 CPU 都有一个单独的 TSS 结构。
- 只用于 存储 ESP0（进入内核态时的栈）。
- task_struct 结构体不会使用 TSS 存储任务信息，而是软件管理任务状态。

Linux 如何使用 TSS

在 Linux 中，TSS 的设置主要用于 中断或系统调用时切换到内核栈：

1.	tss.esp0 存储当前进程的内核栈指针。
2.	当发生 系统调用或中断 时：
    - CPU 自动从 TSS 加载 ESP0。
    - 切换到内核栈，执行内核代码。
    - 处理完成后，再切换回用户栈。

5. 现代 CPU 为什么不使用 TSS 进行任务切换？

在 80386 时代，任务切换（Task Switching）可以由 硬件自动完成，但：

- 硬件任务切换性能较低（TSS 切换涉及大量寄存器存储和恢复）。
- 现代操作系统 采用软件调度，自己管理进程切换。
- CR3（页目录表基址）会在任务切换时变更，导致 TLB（翻译后备缓冲区）刷新，影响性能。

因此，现代 OS 只用 TSS 来管理栈，而不会使用它做任务切换。


6. 总结

|功能 |	是否使用 TSS？	|说明 |
|--|--|--|
| 硬件任务切换	|❌ 不使用	|现代 OS 使用 软件任务切换（上下文切换由 OS 代码完成）。 |
| 用户态 -> 内核态切换	|✅ 使用|系统调用/中断 时，CPU 自动从 TSS 加载 ESP0（内核栈）。 |
| I/O 端口权限管理	|✅ 使用	|通过 TSS 的 I/O 位图 限制进程访问 I/O 端口。|

在现代系统中，TSS 主要用于管理内核栈，而任务切换由操作系统软件完成。
