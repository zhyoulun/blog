# PROGRAM OR TASK RESTART

为了允许在处理异常或中断后重新启动程序或任务，除中止类异常外，所有异常都保证在精确的指令边界上报告，并且所有中断都保证在指令边界上被捕获。

对于故障类异常，处理器在生成异常时保存的返回指令指针指向故障指令。因此，在处理故障后重新启动程序或任务时，故障指令会被重新启动（重新执行）。重新启动故障指令通常用于处理访问操作数被阻止时生成的异常。最常见的故障示例是页错误异常（#PF），当程序或任务引用不在内存中的页面中的操作数时会发生该异常。当发生页错误异常时，异常处理程序可以将页面加载到内存中，并通过重新启动故障指令来恢复程序或任务的执行。为了确保这种指令重新启动对当前执行的程序或任务是透明的，处理器会保存必要的寄存器和堆栈指针，以允许其恢复到执行故障指令之前的状态。

对于陷阱类异常，返回指令指针指向陷阱指令之后的指令。如果在执行转移指令时检测到陷阱，返回指令指针会反映转移。例如，如果在执行 **JMP** 指令时检测到陷阱，返回指令指针指向 **JMP** 指令的目标地址，而不是 **JMP** 指令之后的下一个地址。所有陷阱异常都允许在不丢失连续性的情况下重新启动程序或任务。例如，溢出异常是一种陷阱异常。在这里，返回指令指针指向测试 **EFLAGS** 寄存器中 **OF**（溢出）标志的 **INTO** 指令之后的指令。该异常的陷阱处理程序会解决溢出条件。从陷阱处理程序返回后，程序或任务执行会在 **INTO** 指令之后的下一条指令继续。

中止类异常不支持可靠地重新启动程序或任务。中止处理程序通常设计为收集中止异常发生时处理器状态的诊断信息，然后尽可能优雅地关闭应用程序和系统。

中断严格支持在不丢失连续性的情况下重新启动被中断的程序和任务。为中断保存的返回指令指针指向处理器捕获中断时指令边界上要执行的下一条指令。如果刚刚执行的指令带有重复前缀，则中断在当前迭代结束时被捕获，寄存器设置为执行下一次迭代。

P6 系列处理器的推测执行能力不会影响处理器捕获中断。中断在指令执行的退休阶段位于指令边界时被捕获；因此，它们总是在“顺序”指令流中被捕获。有关 P6 系列处理器的微架构及其对乱序指令执行的支持的更多信息，请参见《IA-32 Intel 架构软件开发人员手册》第 1 卷的第 2 章“Intel 架构简介”。

需要注意的是，Pentium 处理器和早期的 IA-32 处理器也会执行不同程度的指令预取和初步解码；然而，在这里，异常和中断也只有在指令实际“顺序”执行时才会被触发。对于给定的代码示例，当代码在任何 IA-32 处理器系列上执行时，异常的触发将是一致的（除非定义了新的异常或新的操作码）。