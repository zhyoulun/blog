# EXCEPTION AND INTERRUPT HANDLING
处理器对异常和中断处理程序的调用方式与通过 **CALL** 指令调用过程或任务的方式类似。当响应异常或中断时，处理器使用异常或中断向量作为 IDT 中描述符的索引。如果索引指向中断门或陷阱门，处理器会以类似于通过调用门调用 **CALL** 的方式调用异常或中断处理程序（参见第 4.8.2 节“门描述符”到第 4.8.6 节“从被调用过程返回”）。如果索引指向任务门，处理器会以类似于通过任务门调用 **CALL** 的方式执行任务切换到异常或中断处理程序任务（参见第 6.3 节“任务切换”）。

## Exception- or Interrupt-Handler Procedures

中断门或陷阱门引用在当前执行任务的上下文中运行的异常或中断处理程序过程（参见图 5-3）。门的段选择子指向 GDT 或当前 LDT 中可执行代码段的段描述符。门描述符的偏移字段指向异常或中断处理程序过程的起始位置。


![](/static/images/2502/p047.png)

当处理器调用异常或中断处理程序过程时，它会将 **EFLAGS** 寄存器、**CS** 寄存器和 **EIP** 寄存器的当前状态保存在堆栈中（参见图 5-4）。（**CS** 和 **EIP** 寄存器为处理程序提供了返回指令指针。）如果异常导致错误代码被保存，则会在 **EIP** 值之后将其压入堆栈。

如果处理程序过程将以与被中断过程相同的特权级别执行，则处理程序使用当前堆栈。

如果处理程序过程将以数值上更低的特权级别执行，则会发生堆栈切换。当发生堆栈切换时，返回堆栈的堆栈指针也会保存在堆栈中。（**SS** 和 **ESP** 寄存器为处理程序提供了返回堆栈指针。）处理程序使用的堆栈的段选择子和堆栈指针从当前执行任务的 TSS 中获取。处理器将被中断过程的堆栈中的 **EFLAGS**、**SS**、**ESP**、**CS**、**EIP** 和错误代码信息复制到处理程序的堆栈中。

![](/static/images/2502/p048.png)
要从异常或中断处理程序过程返回，处理程序必须使用 **IRET**（或 **IRETD**）指令。**IRET** 指令与 **RET** 指令类似，但它会将保存的标志恢复到 **EFLAGS** 寄存器中。**EFLAGS** 寄存器的 **IOPL** 字段仅在 **CPL** 为 0 时恢复。**IF** 标志仅在 **CPL** 小于或等于 **IOPL** 时更改。有关 **IRET** 指令的完整操作，请参见《IA-32 Intel 架构软件开发人员手册》第 2 卷第 3 章中的“IRET/IRETD—中断返回”。如果在调用处理程序过程时发生了堆栈切换，**IRET** 指令会在返回时切换回被中断过程的堆栈。

#### 5.12.1.1. 异常和中断处理程序的保护  
异常和中断处理程序的特权级别保护类似于通过调用门调用普通过程时使用的保护机制（参见第 4.8.4 节“通过调用门访问代码段”）。处理器不允许将执行转移到特权级别低于 **CPL** 的异常或中断处理程序代码段（数值上更高的特权级别）。  

尝试违反此规则会导致一般保护异常（#GP）。异常和中断处理程序的保护机制在以下方面有所不同：  
- 由于中断和异常向量没有 **RPL**，因此在隐式调用异常和中断处理程序时不会检查 **RPL**。  
- 仅当使用 **INT n**、**INT 3** 或 **INTO** 指令生成异常或中断时，处理器才会检查中断门或陷阱门的 **DPL**。此时，**CPL** 必须小于或等于门的 **DPL**。此限制防止应用程序或运行在特权级别 3 的过程使用软件中断访问关键的异常处理程序（例如页错误处理程序），前提是这些处理程序被放置在更高特权的代码段中（数值上更低的特权级别）。对于硬件生成的中断和处理器检测到的异常，处理器会忽略中断门和陷阱门的 **DPL**。  

由于异常和中断通常不会在可预测的时间发生，这些特权规则有效地限制了异常和中断处理程序可以运行的特权级别。可以使用以下技术之一来避免特权级别违规：  
- 异常或中断处理程序可以放置在一致代码段中。此技术可用于仅需要访问堆栈上数据的处理程序（例如，除零错误异常）。如果处理程序需要来自数据段的数据，则数据段需要可从特权级别 3 访问，这将使其不受保护。  
- 处理程序可以放置在特权级别 0 的非一致代码段中。无论被中断程序或任务运行在什么 **CPL**，此处理程序都会运行。  

#### 5.12.1.2. 异常或中断处理程序的标志使用  
当通过中断门或陷阱门访问异常或中断处理程序时，处理器在将 **EFLAGS** 寄存器的内容保存到堆栈后，会清除 **EFLAGS** 寄存器中的 **TF** 标志。（在调用异常和中断处理程序时，处理器还会在将 **VM**、**RF** 和 **NT** 标志保存到堆栈后清除它们。）清除 **TF** 标志可防止指令跟踪影响中断响应。随后的 **IRET** 指令会将 **TF**（以及 **VM**、**RF** 和 **NT**）标志恢复到堆栈上保存的 **EFLAGS** 寄存器内容中的值。  

中断门和陷阱门之间的唯一区别在于处理器处理 **EFLAGS** 寄存器中 **IF** 标志的方式。当通过中断门访问异常或中断处理程序时，处理器会清除 **IF** 标志，以防止其他中断干扰当前中断处理程序。随后的 **IRET** 指令会将 **IF** 标志恢复到堆栈上保存的 **EFLAGS** 寄存器内容中的值。通过陷阱门访问处理程序不会影响 **IF** 标志。  

#### 5.12.2. 中断任务  
当通过 IDT 中的任务门访问异常或中断处理程序时，会发生任务切换。使用单独的任务处理异常或中断具有以下优点：  
- 被中断程序或任务的整个上下文会自动保存。  
- 新的 TSS 允许处理程序在处理异常或中断时使用新的特权级别 0 堆栈。如果当前特权级别 0 堆栈已损坏时发生异常或中断，通过任务门访问处理程序可以通过为处理程序提供新的特权级别 0 堆栈来防止系统崩溃。  
- 通过为处理程序提供单独的 LDT，可以将其与其他任务进一步隔离。  

使用单独的任务处理中断的缺点是任务切换时必须保存的机器状态量使其比使用中断门更慢，从而导致中断延迟增加。  

IDT 中的任务门引用 GDT 中的 TSS 描述符（参见图 5-5）。切换到处理程序任务的方式与普通任务切换相同（参见第 6.3 节“任务切换”）。返回被中断任务的链接存储在处理程序任务的 TSS 的“前一任务链接”字段中。如果异常生成了错误代码，则此错误代码会复制到新任务的堆栈中。  

当在操作系统中使用异常或中断处理程序任务时，实际上有两种机制可用于调度任务：软件调度程序（操作系统的一部分）和硬件调度程序（处理器中断机制的一部分）。软件调度程序需要适应在启用中断时可能调度的中断任务。  

**注意：**  
由于 IA-32 架构任务不可重入，中断处理程序任务必须在完成中断处理和执行 **IRET** 指令之间禁用中断。此操作可防止在中断任务的 TSS 仍标记为忙时发生另一个中断，否则会导致一般保护异常（#GP）。

![](/static/images/2502/p049.png)