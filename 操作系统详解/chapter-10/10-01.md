IA-32 架构提供了多种机制来管理和提高连接到同一系统总线的多个处理器的性能。这些机制包括：
- **总线锁定和/或缓存一致性管理**，用于在系统内存上执行原子操作。  
- **序列化指令**（这些指令仅适用于 Pentium 4、Intel Xeon、P6 系列和 Pentium 处理器）。  
- **位于处理器芯片上的高级可编程中断控制器（APIC）**（参见第 8 章“高级可编程中断控制器（APIC）”）。APIC 架构是在 Pentium 处理器中引入 IA-32 处理器的。  
- **二级缓存（L2）**。对于 Pentium 4、Intel Xeon 和 P6 系列处理器，L2 缓存包含在处理器封装中，并与处理器紧密耦合。对于 Pentium 和 Intel486 处理器，提供了引脚以支持外部 L2 缓存。  
- **三级缓存（L3）**。对于 Intel Xeon 处理器，L3 缓存包含在处理器封装中，并与处理器紧密耦合。  
- **超线程技术**，这是 IA-32 架构的扩展，使单个处理器核心能够并发执行两个或多个执行线程（参见第 7.6 节“超线程技术”）。  

这些机制在对称多处理（SMP）系统中特别有用；然而，它们也可以用于 IA-32 处理器与专用处理器（如通信、图形或视频处理器）共享系统总线的应用程序中。

这些多处理机制的主要目标如下：
- **维护系统内存一致性**——当两个或多个处理器同时尝试访问系统内存中的同一地址时，必须提供某种通信机制或内存访问协议，以促进数据一致性，并在某些情况下允许一个处理器临时锁定内存位置。  
- **维护缓存一致性**——当一个处理器访问另一个处理器缓存的数据时，它不能接收错误的数据。如果它修改了数据，所有访问该数据的其他处理器都必须接收修改后的数据。  
- **允许对内存写入的可预测排序**——在某些情况下，内存写入必须按照编程顺序在外部观察到。  
- **在处理器组之间分配中断处理**——当多个处理器在系统中并行运行时，拥有一个集中机制来接收中断并将其分配给可用处理器进行处理是很有用的。  
- **通过利用当代操作系统和应用程序的多线程和多处理器特性来提高系统性能**。  

IA-32 架构的缓存机制和缓存一致性在第 10 章“内存缓存控制”中讨论。APIC 架构在第 8 章“高级可编程中断控制器（APIC）”中描述。总线与内存锁定、序列化指令、内存排序和超线程技术在以下章节中讨论。

# LOCKED ATOMIC OPERATIONS

32位IA-32处理器支持对系统内存中位置的锁定原子操作。这些操作通常用于管理共享数据结构（如信号量、段描述符、系统段或页表），其中两个或多个处理器可能同时尝试修改相同的字段或标志。处理器使用三种相互依赖的机制来执行锁定原子操作：

1. **保证的原子操作**。
2. **总线锁定**，使用LOCK#信号和LOCK指令前缀。
3. **缓存一致性协议**，确保可以在缓存的数据结构上执行原子操作（缓存锁定）。此机制存在于Pentium 4、Intel Xeon和P6系列处理器中。

这些机制在以下方面相互依赖。某些基本的内存事务（例如在系统内存中读取或写入一个字节）始终保证以原子方式处理。也就是说，一旦开始，处理器保证在允许另一个处理器或总线代理访问该内存位置之前完成操作。处理器还支持总线锁定，以执行通常需要以原子方式处理但不会自动以这种方式处理的选择性内存操作（例如在共享内存区域中的读-修改-写操作）。由于频繁使用的内存位置通常缓存在处理器的L1或L2缓存中，因此原子操作通常可以在处理器的缓存中执行，而无需置位总线锁定。在这里，处理器的缓存一致性协议确保在缓存的内存位置上执行原子操作时，其他缓存相同内存位置的处理器得到适当管理。

请注意，随着IA-32处理器复杂性的发展，处理锁定原子操作的机制也在不断演变。因此，较新的IA-32处理器（如Pentium 4、Intel Xeon和P6系列处理器）提供了比早期IA-32处理器更精细的锁定机制，如下文所述。


## Guaranteed Atomic Operations

Pentium 4、Intel Xeon、P6系列、Pentium和Intel486处理器保证以下基本内存操作始终以原子方式执行：

- **读取或写入一个字节**。
- **读取或写入对齐在16位边界上的字**。
- **读取或写入对齐在32位边界上的双字**。

Pentium 4、Intel Xeon、P6系列和Pentium处理器保证以下额外的内存操作始终以原子方式执行：

- **读取或写入对齐在64位边界上的四字**。
- **对适合32位数据总线的未缓存内存位置的16位访问**。

P6系列处理器保证以下额外的内存操作始终以原子方式执行：

- **对适合32字节缓存行的未对齐16位、32位和64位缓存内存的访问**。

Pentium 4、Intel Xeon、P6系列、Pentium和Intel486处理器不保证跨越总线宽度、缓存行和页边界的可缓存内存访问是原子的。Pentium 4、Intel Xeon和P6系列处理器提供总线控制信号，允许外部内存子系统使拆分访问成为原子操作；然而，未对齐的数据访问会严重影响处理器的性能，应尽量避免。

## Bus Locking


IA-32处理器提供了一个LOCK#信号，该信号在某些关键内存操作期间自动置位，以锁定系统总线。当此输出信号置位时，来自其他处理器或总线代理的总线控制请求会被阻止。软件可以通过在指令前加上LOCK前缀来指定其他应遵循LOCK语义的场合。

对于Intel386、Intel486和Pentium处理器，显式锁定的指令将导致LOCK#信号置位。硬件设计师有责任在系统硬件中提供LOCK#信号，以控制处理器之间的内存访问。

对于Pentium 4、Intel Xeon和P6系列处理器，如果被访问的内存区域在处理器内部缓存，LOCK#信号通常不会置位；相反，锁定仅应用于处理器的缓存（参见第7.1.4节“LOCK操作对处理器内部缓存的影响”）。

### AUTOMATIC LOCKING

处理器自动遵循 **LOCK** 语义的操作如下：
- 当执行引用内存的 **XCHG** 指令时。  
- 当设置 TSS 描述符的 **B**（忙）标志时。处理器在切换到任务时会测试并设置 TSS 描述符类型字段中的忙标志。为了确保两个处理器不会同时切换到同一任务，处理器在测试和设置此标志时遵循 **LOCK** 语义。  
- 当更新段描述符时。当加载段描述符时，如果访问标志未设置，处理器将设置段描述符中的访问标志。在此操作期间，处理器遵循 **LOCK** 语义，以便描述符在更新时不会被另一个处理器修改。为了使此操作有效，更新描述符的操作系统过程应使用以下步骤：  
  — 使用锁定操作修改访问权限字节，以指示段描述符不存在，并为类型字段指定一个值，表明描述符正在更新。  
  — 更新段描述符的字段（此操作可能需要多次内存访问；因此，不能使用锁定操作）。  
  — 使用锁定操作修改访问权限字节，以指示段描述符有效且存在。  
  请注意，Intel386 处理器总是更新段描述符中的访问标志，无论它是否已设置。Pentium 4、Intel Xeon、P6 系列、Pentium 和 Intel486 处理器仅在该标志未设置时更新它。  
- 当更新页目录和页表条目时。在更新页目录和页表条目时，处理器使用锁定周期来设置页目录和页表条目中的访问和脏标志。  
- 确认中断。在中断请求后，中断控制器可能使用数据总线将中断向量发送给处理器。处理器在此期间遵循 **LOCK** 语义，以确保在传输中断向量时数据总线上不会出现其他数据。

### SOFTWARE CONTROLLED BUS LOCKING

为了显式强制LOCK语义，软件可以在以下指令用于修改内存位置时使用LOCK前缀。当LOCK前缀与任何其他指令一起使用或未对内存进行写操作时（即，当目标操作数在寄存器中时），会生成无效操作码异常（#UD）。

- **位测试和修改指令**（BTS、BTR和BTC）。
- **交换指令**（XADD、CMPXCHG和CMPXCHG8B）。
- **XCHG指令自动假定LOCK前缀**。
- **以下单操作数算术和逻辑指令**：INC、DEC、NOT和NEG。
- **以下双操作数算术和逻辑指令**：ADD、ADC、SUB、SBB、AND、OR和XOR。

锁定指令保证只锁定由目标操作数定义的内存区域，但系统可能将其解释为锁定更大的内存区域。

软件应使用相同的地址和操作数长度访问信号量（用于多个处理器之间通信的共享内存）。例如，如果一个处理器使用字访问信号量，其他处理器不应使用字节访问信号量。

总线锁定的完整性不受内存字段对齐的影响。LOCK语义会遵循更新整个操作数所需的任意多个总线周期。然而，建议锁定访问对齐到其自然边界以获得更好的系统性能：

- **8位访问（锁定或其他）的任何边界**。
- **锁定字访问的16位边界**。
- **锁定双字访问的32位边界**。
- **锁定四字访问的64位边界**。

锁定操作相对于所有其他内存操作和所有外部可见事件是原子的。只有指令获取和页表访问可以绕过锁定指令。锁定指令可用于同步一个处理器写入并由另一个处理器读取的数据。

对于P6系列处理器，锁定操作会序列化所有未完成的加载和存储操作（即等待它们完成）。此规则也适用于Pentium 4和Intel Xeon处理器，但有一个例外：引用弱有序内存类型（如WC内存类型）的加载操作可能不会被序列化。

锁定指令不应用于确保写入的数据可以作为指令获取。

**注意**  
当前版本的Pentium 4、Intel Xeon、P6系列、Pentium和Intel486处理器的锁定指令允许写入的数据作为指令获取。然而，Intel建议需要自修改代码的开发人员使用不同的同步机制，如下文所述。

## Handling Self- and Cross-Modifying Code

处理器将数据写入当前执行的代码段并意图将该数据作为代码执行的行为称为**自修改代码**。IA-32 处理器在执行自修改代码时表现出模型特定的行为，具体取决于代码修改的位置距离当前执行指针有多远。随着处理器架构变得更加复杂并开始推测性地在执行点之前执行代码（如 Pentium 4、Intel Xeon 和 P6 系列处理器），关于应执行修改前还是修改后代码的规则变得模糊。为了编写自修改代码并确保其符合当前和未来版本的 IA-32 架构，必须选择以下两种编码选项之一。

(* 选项 1 *)  
将修改后的代码（作为数据）存储到代码段；  
跳转到新代码或中间位置；  
执行新代码；  

(* 选项 2 *)  
将修改后的代码（作为数据）存储到代码段；  
执行序列化指令；(* 例如，CPUID 指令 *)  
执行新代码；  

（对于旨在在 Pentium 或 Intel486 处理器上运行的程序，不需要使用这些选项之一，但建议使用以确保与 Pentium 4、Intel Xeon 和 P6 系列处理器的兼容性。）

需要注意的是，自修改代码的执行性能将低于非自修改或正常代码。性能下降的程度取决于修改的频率和代码的具体特性。

一个处理器将数据写入第二个处理器当前执行的代码段并意图让第二个处理器将该数据作为代码执行的行为称为**交叉修改代码**。与自修改代码一样，IA-32 处理器在执行交叉修改代码时表现出模型特定的行为，具体取决于代码修改的位置距离执行处理器的当前执行指针有多远。为了编写交叉修改代码并确保其符合当前和未来版本的 IA-32 架构，必须实现以下处理器同步算法。

; 修改处理器的操作  
Memory_Flag ← 0; (* 将 Memory_Flag 设置为非 1 的值 *)  
将修改后的代码（作为数据）存储到代码段；  
Memory_Flag ← 1;  

; 执行处理器的操作  
WHILE (Memory_Flag ≠ 1)  
等待代码更新；  
ELIHW;  
执行序列化指令；(* 例如，CPUID 指令 *)  
开始执行修改后的代码；  

（对于旨在在 Intel486 处理器上运行的程序，不需要使用此选项，但建议使用以确保与 Pentium 4、Intel Xeon、P6 系列和 Pentium 处理器的兼容性。）

与自修改代码一样，交叉修改代码的执行性能将低于非交叉修改（正常）代码，具体取决于修改的频率和代码的具体特性。

## Effects of a LOCK Operation on Internal Processor


**缓存**  
对于Intel486和Pentium处理器，在LOCK操作期间，LOCK#信号始终在总线上置位，即使被锁定的内存区域缓存在处理器中。

对于Pentium 4、Intel Xeon和P6系列处理器，如果在LOCK操作期间被锁定的内存区域在执行LOCK操作的处理器中缓存为写回内存，并且完全包含在缓存行中，处理器可能不会在总线上置位LOCK#信号。相反，它将在内部修改内存位置，并允许其缓存一致性机制确保操作以原子方式执行。此操作称为“缓存锁定”。缓存一致性机制自动防止两个或多个缓存了相同内存区域的处理器同时修改该区域中的数据。