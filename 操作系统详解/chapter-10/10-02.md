# MEMORY ORDERING

**内存排序**是指处理器通过系统总线向系统内存发出读取（加载）和写入（存储）操作的顺序。IA-32 架构支持多种内存排序模型，具体取决于架构的实现。例如，Intel386 处理器强制执行程序排序（通常称为**强排序**），在所有情况下，读取和写入操作按照指令流中出现的顺序在系统总线上发出。

为了优化指令执行，IA-32 架构允许偏离强排序模型，称为 Pentium 4、Intel Xeon 和 P6 系列处理器中的**处理器排序**。这些处理器排序的变体允许性能增强操作，例如允许读取操作在缓冲写入之前进行。这些变体的目标是提高指令执行速度，同时保持内存一致性，即使在多处理器系统中也是如此。

以下部分描述了 Intel486 和 Pentium 处理器以及 Pentium 4、Intel Xeon 和 P6 系列处理器使用的内存排序模型。

## Memory Ordering in the Pentium® and Intel486™

**处理器**  
Pentium和Intel486处理器遵循处理器有序内存模型；然而，在大多数情况下，它们表现为强有序处理器。读取和写入总是以编程顺序出现在系统总线上——除了以下显示处理器排序的情况。当所有缓冲的写入都是缓存命中时，读取未命中允许在系统总线上先于缓冲的写入执行，因此不会指向与读取未命中访问的相同地址。

在I/O操作的情况下，读取和写入总是以编程顺序出现。旨在在处理器有序处理器（如Pentium 4、Intel Xeon和P6系列处理器）中正确运行的软件不应依赖于Pentium或Intel486处理器的相对强有序性。相反，它应确保通过使用适当的锁定或序列化操作（参见第7.2.4节“加强或削弱内存排序模型”），明确要求对控制处理器之间并发执行的共享变量的访问遵守编程顺序。

**内存排序**  
Pentium 4、Intel Xeon和P6系列处理器也使用处理器有序内存排序模型，可以进一步定义为“带有存储缓冲区转发的写有序”模型。该模型可以描述如下。

在单处理器系统中，对于定义为写回可缓存的内存区域，适用以下排序规则：

1. **读取可以推测性地执行，并且可以按任何顺序执行**。
2. **读取可以绕过缓冲的写入，但处理器是自一致的**。
3. **写入内存总是以编程顺序执行，除了使用CLFLUSH指令执行的写入和使用非临时移动指令（MOVNTI、MOVNTQ、MOVNTDQ、MOVNTPS和MOVNTPD）执行的流式存储（写入）**。
4. **写入可以被缓冲**。
5. **写入不会推测性地执行；它们只为实际已退休的指令执行**。
6. **缓冲写入的数据可以转发给处理器内等待的读取**。
7. **读取或写入不能绕过（先于）I/O指令、锁定指令或序列化指令**。
8. **读取不能绕过LFENCE和MFENCE指令**。
9. **写入不能绕过SFENCE和MFENCE指令**。

第二条规则允许读取绕过写入。然而，如果写入与读取访问的是相同的内存位置，处理器的内部“窥探”机制将检测到冲突，并在处理器执行使用该值的指令之前更新已缓存的读取。第六条规则构成了写有序模型的例外。

请注意，术语“带有存储缓冲区转发的写有序”（在本节开头引入）指的是规则2和6的联合效果。

在多处理器系统中，适用以下排序规则：

- **单个处理器使用与单处理器系统相同的排序规则**。
- **单个处理器的写入被所有处理器以相同的顺序观察到**。
- **系统总线上各个处理器的写入彼此之间没有排序**。

后一条规则可以通过图7-1中的示例来澄清。考虑系统中的三个处理器，每个处理器执行三次写入，分别写入三个定义的位置（A、B和C）。单独来看，处理器以相同的编程顺序执行写入，但由于总线仲裁和其他内存访问机制，三个处理器写入各个内存位置的顺序在每次在处理器上执行相应代码序列时可能会有所不同。位置A、B和C的最终值在每次执行写入序列时可能会有所不同。

本节描述的处理器排序模型与Pentium和Intel486处理器使用的模型几乎相同。Pentium 4、Intel Xeon和P6系列处理器的唯一增强是：

- **增加了对推测性读取的支持**。
- **存储缓冲区转发，当读取绕过对相同内存位置的写入时**。
- **长字符串存储和字符串移动操作中的乱序存储**（参见第7.2.3节“Pentium 4、Intel Xeon和P6系列处理器中字符串操作的乱序存储”）。

![](/static/images/2502/p061.png)

## Out-of-Order Stores For String Operations in Pentium 4, Intel Xeon, and P6 Family Processors

Pentium 4、Intel Xeon 和 P6 系列处理器在字符串存储操作（由 **MOVS** 和 **STOS** 指令启动）期间修改处理器的操作以最大化性能。一旦满足“快速字符串”操作的初始条件（如下所述），从外部角度来看，处理器将以缓存行逐行模式处理字符串。这导致处理器在字符串长度内循环发出源地址的缓存行读取和目标地址的外部总线无效化，因为知道目标缓存行中的所有字节都将被修改。在此模式下，处理器仅在缓存行边界上接受中断。在此模式下，目标行无效化（因此存储）可能会以乱序在外部总线上发出。

依赖于顺序存储排序的代码不应将字符串操作用于整个要存储的数据结构。数据和信号量应分开。依赖于顺序的代码应使用离散的信号量，在字符串操作之后唯一存储，以允许所有处理器正确看到有序数据。

“快速字符串”操作的初始条件：
- 对于 Pentium III 处理器，**EDI** 和 **ESI** 必须 8 字节对齐。对于 Pentium 4 处理器，**EDI** 必须 8 字节对齐。  
- 字符串操作必须以升序地址顺序执行。  
- 初始操作计数器（**ECX**）必须等于或大于 64。  
- 源和目标地址的重叠不得小于缓存行（Pentium 4 和 Intel Xeon 处理器为 64 字节；P6 系列和 Pentium 处理器为 32 字节）。  
- 源和目标地址的内存类型必须为 **WB** 或 **WC**。  

## 7.2.4. 加强或削弱内存排序模型  
IA-32 架构提供了几种机制来加强或削弱内存排序模型，以处理特殊的编程情况。这些机制包括：
- **I/O 指令**、**锁定指令**、**LOCK 前缀**和**序列化指令**强制处理器更强的排序。  
- **SFENCE** 指令（在 Pentium III 处理器中引入 IA-32 架构）以及 **LFENCE** 和 **MFENCE** 指令（在 Pentium 4 和 Intel Xeon 处理器中引入）为特定类型的内存操作提供内存排序和序列化能力。  
- **内存类型范围寄存器（MTRRs）** 可用于加强或削弱特定物理内存区域的内存排序（参见第 10.11 节“内存类型范围寄存器（MTRRs）”）。MTRRs 仅在 Pentium 4、Intel Xeon 和 P6 系列处理器中可用。  
- **页属性表（PAT）** 可用于加强特定页面或页面组的内存排序（参见第 10.12 节“页属性表（PAT）”）。PAT 仅在 Pentium 4、Intel Xeon 和 Pentium III 处理器中可用。  

这些机制可以如下使用。  
总线上的内存映射设备和其他 I/O 设备通常对写入其 I/O 缓冲区的顺序敏感。可以使用 **I/O 指令**（**IN** 和 **OUT** 指令）对此类访问施加强写入顺序，如下所示。在执行 I/O 指令之前，处理器等待程序中的所有先前指令完成，并且所有缓冲写入都刷新到内存。只有指令获取和页表遍历可以绕过 I/O 指令。在处理器确定 I/O 指令已完成之前，不会开始执行后续指令。

多处理器系统中的同步机制可能依赖于强内存排序模型。在这里，程序可以使用锁定指令（如 **XCHG** 指令或 **LOCK** 前缀）来确保对内存的读取-修改-写入操作以原子方式执行。锁定操作通常类似于 I/O 操作，因为它们等待所有先前指令完成，并且所有缓冲写入都刷新到内存（参见第 7.1.2 节“总线锁定”）。

程序同步也可以通过**序列化指令**执行（参见第 7.4 节“序列化指令”）。这些指令通常用于关键过程或任务边界，以强制完成所有先前指令，然后再跳转到新代码段或发生上下文切换。与 I/O 和锁定指令一样，处理器等待所有先前指令完成，并且所有缓冲写入都刷新到内存，然后再执行序列化指令。

**SFENCE**、**LFENCE** 和 **MFENCE** 指令提供了一种高效的方式来确保在产生弱排序结果的例程和消费该数据的例程之间的加载和存储内存排序。这些指令的功能如下：
- **SFENCE**——序列化程序指令流中 **SFENCE** 指令之前发生的所有存储（写入）操作，但不影响加载操作。  
- **LFENCE**——序列化程序指令流中 **LFENCE** 指令之前发生的所有加载（读取）操作，但不影响存储操作。  
- **MFENCE**——序列化程序指令流中 **MFENCE** 指令之前发生的所有存储和加载操作。  

请注意，**SFENCE**、**LFENCE** 和 **MFENCE** 指令提供了一种比 **CPUID** 指令更高效的控制内存排序的方法。

**MTRRs** 在 P6 系列处理器中引入，用于定义特定物理内存区域的缓存特性。以下是使用 MTRRs 设置的内存类型来加强或削弱 Pentium 4、Intel Xeon 和 P6 系列处理器的内存排序的两个示例：
- **强不可缓存（UC）内存类型** 强制对内存访问施加强排序模型。在这里，对 UC 内存区域的所有读取和写入都出现在总线上，并且不会执行乱序或推测性访问。此内存类型可应用于专用于内存映射 I/O 设备的地址范围，以强制强内存排序。  
- 对于可以接受弱排序的内存区域，可以选择**写回（WB）内存类型**。在这里，读取可以推测性地执行，写入可以缓冲和合并。对于这种类型的内存，缓存锁定在原子（锁定）操作上执行，这些操作不会跨越缓存行，这有助于减少与使用典型同步指令（如 **XCHG**）相关的性能损失，这些指令在整个读取-修改-写入操作期间锁定总线。对于 WB 内存类型，如果内存访问包含在缓存行内，**XCHG** 指令会锁定缓存而不是总线。

**PAT** 在 Pentium III 处理器中引入，以增强可分配给页面或页面组的缓存特性。PAT 机制通常用于在页面级别加强缓存特性，相对于 MTRRs 建立的缓存特性。表 10-7 显示了 PAT 与 MTRRs 的交互。

建议为 Pentium 4、Intel Xeon 和 P6 系列处理器编写的软件采用处理器排序模型或更弱的内存排序模型。Pentium 4、Intel Xeon 和 P6 系列处理器不实现强内存排序模型，除非使用 UC 内存类型。尽管 Pentium 4、Intel Xeon 和 P6 系列处理器支持处理器排序，但英特尔不保证未来的处理器将支持此模型。为了使软件可移植到未来的处理器，建议操作系统提供基于 I/O、锁定和/或序列化指令的关键区域和资源控制构造和 API（应用程序接口），以同步多处理器系统中对共享内存区域的访问。此外，在系统硬件不支持此内存排序模型的情况下，软件不应依赖于处理器排序。
