# SERIALIZING INSTRUCTIONS

IA-32架构定义了几条序列化指令。这些指令强制处理器在获取和执行下一条指令之前，完成对标志、寄存器和内存的所有修改，并清空所有缓冲的写入内存。例如，当使用MOV指令将新值加载到控制寄存器CR0以启用保护模式时，处理器在进入保护模式之前必须执行序列化操作。此序列化操作确保在切换到保护模式之前，所有在实地址模式下启动的操作都已完成。

序列化指令的概念是在Pentium处理器中引入IA-32架构的，以支持并行指令执行。序列化指令对于未实现并行指令执行的Intel486及更早的处理器没有意义。需要注意的是，在Pentium 4、Intel Xeon和P6系列处理器上执行序列化指令会限制推测执行，因为推测执行的指令结果会被丢弃。

以下是序列化指令：

- **特权序列化指令**：MOV（到控制寄存器）、MOV（到调试寄存器）、WRMSR、INVD、INVLPG、WBINVD、LGDT、LLDT、LIDT和LTR。
- **非特权序列化指令**：CPUID、IRET和RSM。
- **非特权内存排序指令**：SFENCE、LFENCE和MFENCE。

当处理器序列化指令执行时，它确保在执行下一条指令之前完成所有挂起的内存事务，包括存储在存储缓冲区中的写入。任何指令都不能绕过序列化指令，序列化指令也不能绕过任何其他指令（读取、写入、指令获取或I/O）。

CPUID指令可以在任何特权级别执行，以序列化指令执行，除了修改EAX、EBX、ECX和EDX寄存器外，对程序流程没有影响。SFENCE、LFENCE和MFENCE指令提供了更细粒度的控制内存加载和存储的序列化（参见第7.2.4节“加强或削弱内存排序模型”）。

以下是关于序列化指令的额外值得注意的信息：

- **处理器在序列化指令执行时不会将其数据缓存中的修改数据写回外部内存**。软件可以通过执行WBINVD指令（一条序列化指令）强制修改数据写回。需要注意的是，频繁使用WBINVD指令会严重降低系统性能。
- **当执行启用或禁用分页的指令（即更改控制寄存器CR0中的PG标志）时，该指令后应跟随一条跳转指令**。跳转指令的目标指令使用PG标志的新设置（即启用或禁用分页）获取，但跳转指令本身使用先前的设置获取。Pentium 4、Intel Xeon和P6系列处理器在MOV指令写入CR0后不需要跳转操作（因为在Pentium 4、Intel Xeon或P6系列处理器中使用MOV指令写入CR0是完全序列化的）。然而，为了保持与为其他IA-32处理器编写的代码的向后和向前兼容性，建议执行跳转操作。
- **每当执行更改CR3内容的指令且分页启用时，下一条指令使用与CR3新值对应的转换表获取**。因此，下一条指令及后续指令应基于CR3的新值进行映射。（TLB中的全局条目不会无效，参见第10.9节“使转换后备缓冲器（TLB）无效”。）
- **Pentium 4、Intel Xeon、P6系列和Pentium处理器使用分支预测技术通过在分支指令执行之前预取分支指令的目标来提高性能**。因此，在执行分支指令时，指令执行不是确定性序列化的。