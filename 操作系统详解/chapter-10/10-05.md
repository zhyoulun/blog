# MULTIPLE-PROCESSOR (MP) INITIALIZATION

IA-32 架构（从 P6 系列处理器开始）定义了一种称为**多处理器规范版本 1.4** 的多处理器（MP）初始化协议。该规范定义了在多处理器系统中 IA-32 处理器使用的引导协议。（在这里，多处理器定义为两个或更多处理器。）MP 初始化协议具有以下重要特性：
- 它支持多处理器的受控引导，而无需专用系统硬件。  
- 它允许硬件启动系统，而无需专用信号或预定义的引导处理器。  
- 它允许所有 IA-32 处理器以相同方式引导，包括具有超线程技术的处理器。  

执行 MP 初始化协议的机制因 IA-32 处理器系列而异，如下所示：
- **对于 P6 系列处理器**——BSP 和 AP 的选择（参见第 7.5.1 节“BSP 和 AP 处理器”）通过 APIC 总线上的仲裁处理，使用 **BIPI** 和 **FIPI** 消息。有关 P6 系列处理器的 MP 初始化的完整讨论，请参见附录 C。  
- **家族、型号和步进 ID 不超过 F09H 的 Intel Xeon 处理器**——BSP 和 AP 的选择（参见第 7.5.1 节“BSP 和 AP 处理器”）通过系统总线上的仲裁处理，使用 **BIPI** 和 **FIPI** 消息。有关 Intel Xeon 处理器的 MP 初始化的完整讨论，请参见第 7.5.3 节“Intel Xeon 处理器的 MP 初始化协议算法”。  
- **家族、型号和步进 ID 为 F0AH 及以上的 Intel Xeon 处理器**——BSP 和 AP 的选择通过特殊的系统总线周期处理，而不使用 **BIPI** 和 **FIPI** 消息仲裁。此选择方法也在第 7.5.3 节“Intel Xeon 处理器的 MP 初始化协议算法”中描述。  

处理器的家族、型号和步进 ID 在执行 **CPUID** 指令时（**EAX** 寄存器中的值为 1）在 **EAX** 寄存器中给出。

## BSP and AP Processors

MP初始化协议定义了两类处理器：引导处理器（BSP）和应用处理器（AP）。在MP系统上电或复位后，系统硬件动态选择系统总线上的一个处理器作为BSP。其余处理器被指定为AP。

作为BSP选择机制的一部分，BSP的IA32_APIC_BASE MSR中的BSP标志被设置（参见图8-5），表明它是BSP。所有其他处理器的该标志被清除。BSP执行BIOS的引导代码来配置APIC环境，设置系统范围的数据结构，并启动和初始化AP。当BSP和AP初始化完成后，BSP开始执行操作系统初始化代码。

上电或复位后，AP完成最小的自配置，然后等待来自BSP处理器的启动信号（SIPI消息）。接收到SIPI消息后，AP执行BIOS AP配置代码，最终将AP置于停机状态。

在支持超线程技术的IA-32处理器中，MP初始化协议将系统总线上的每个逻辑处理器视为一个单独的处理器（具有唯一的APIC ID）。在启动过程中，一个逻辑处理器被选为BSP，其余逻辑处理器被指定为AP。

## MP Initialization Protocol Requirements and Restrictions

### 针对 Intel Xeon 处理器的 MP 初始化协议  
MP 初始化协议对系统施加了以下要求和限制：
- **MP 协议仅在电源启动或复位后执行**。如果 MP 协议已完成并选择了 BSP，则后续的 **INIT**（无论是针对特定处理器还是系统范围）不会导致 MP 协议重复执行。相反，每个处理器检查其 BSP 标志（在 **IA32_APIC_BASE MSR** 中）以确定它是否应执行 BIOS 引导代码（如果是 BSP）或进入等待 SIPI 状态（如果是 AP）。  
- **在 MP 初始化协议期间，系统中所有能够向处理器传递中断的设备必须被禁止这样做**。禁止中断的时间包括 BSP 向 AP 发出 **INIT-SIPI-SIPI** 序列与 AP 响应序列中最后一个 SIPI 之间的窗口期。

## MP Initialization Protocol Algorithm for the Intel Xeon Processors

在MP系统上电或复位后，系统中的Intel Xeon处理器执行MP初始化协议算法，以初始化系统总线上的每个处理器。在执行此算法的过程中，执行以下启动和初始化操作：

1. **为系统总线上的每个处理器分配一个唯一的8位APIC ID**，基于系统拓扑（参见第7.5.5节“识别MP系统中的处理器”）。此ID写入每个处理器的本地APIC ID寄存器。
2. **根据其APIC ID为每个处理器分配唯一的仲裁优先级**。
3. **每个处理器与系统总线上的其他处理器同时执行其内部BIST**。
4. **BIST完成后，处理器使用硬件定义的选择机制从系统总线上的可用处理器中选择BSP和AP**。BSP选择机制因处理器的系列、型号和步进ID而异，如下所示：
   - **系列、型号和步进ID为F0AH及以后**：
     - 处理器开始监控BNR#信号，该信号在切换。当BNR#引脚停止切换时，每个处理器尝试在系统总线上发出NOP特殊周期。
     - 具有最高仲裁优先级的处理器成功发出NOP特殊周期并被提名为BSP。该处理器在其IA32_APIC_BASE MSR中设置BSP标志，然后从复位向量（物理地址FFFF FFF0H）开始获取并执行BIOS引导代码。
     - 其余处理器（未能发出NOP特殊周期的）被指定为AP。它们保持其BSP标志为清除状态，并进入“等待SIPI状态”。
   - **系列、型号和步进ID为F09H及之前**：
     - 每个处理器广播一个BIPI到“包括自己在内的所有处理器”。第一个广播BIPI（并因此接收自己的BIPI向量）的处理器选择自己为BSP，并在其IA32_APIC_BASE MSR中设置BSP标志。（有关BIPI、FIPI和SIPI消息的描述，请参见附录C.1“P6系列处理器MP初始化过程概述”。）
     - 其余处理器（未被选为BSP的）被指定为AP。它们保持其BSP标志为清除状态，并进入“等待SIPI状态”。
     - 新建立的BSP广播一个FIPI消息到“包括自己在内的所有处理器”，BSP和AP将其视为MP初始化结束信号。只有设置了BSP标志的处理器响应FIPI消息。它通过从复位向量（物理地址FFFF FFF0H）开始获取并执行BIOS引导代码来响应。
5. **作为引导代码的一部分，BSP创建ACPI表和MP表，并根据需要将其初始APIC ID添加到这些表中**。
6. **在引导过程结束时，BSP将处理器计数器设置为1，然后向系统中的所有AP广播SIPI消息**。此处，SIPI消息包含指向BIOS AP初始化代码的向量（位于000VV000H，其中VV是SIPI消息中包含的向量）。
7. **AP初始化代码的第一个操作是设置一个（在AP之间的）竞争，以访问BIOS初始化信号量**。第一个到达信号量的AP开始执行初始化代码。（有关信号量实现的详细信息，请参见第7.5.4节“MP初始化示例”。）作为AP初始化过程的一部分，AP根据需要将其APIC ID号添加到ACPI和MP表中，并将处理器计数器增加1。初始化过程完成后，AP执行CLI指令并自行停机。
8. **当每个AP都获得对信号量的访问权并执行AP初始化代码后，BSP建立连接到系统总线的处理器数量，完成执行BIOS引导代码，然后开始执行操作系统引导和启动代码**。
9. **当BSP执行操作系统引导和启动代码时，AP保持在停机状态**。在此状态下，它们仅响应INIT、NMI和SMI。它们还响应窥探和STPCLK#引脚的置位。

以下部分给出了多个Intel Xeon处理器在MP配置中操作的MP初始化协议示例（包含代码）。

附录D“编程LINT0和LINT1输入”描述了在完成MP配置后如何编程处理器本地APIC的LINT[0:1]引脚。

## MP Initialization Example

以下示例说明了在建立 BSP 和 AP 后，使用 MP 初始化协议在 MP 系统中初始化 IA-32 处理器的情况。此代码在使用 MP 初始化协议的任何 IA-32 处理器上成功运行，包括 P6 系列处理器和 Intel Xeon 处理器（无论是否具有超线程技术）。

以下常量和数据定义用于随附的代码示例。它们基于表 8-1 中定义的 APIC 寄存器地址。

```asm
ICR_LOW     EQU 0FEE00300H  
SVR         EQU 0FEE000F0H  
APIC_ID     EQU 0FEE00020H  
LVT3        EQU 0FEE00370H  
APIC_ENABLED EQU 0100H  
BOOT_ID     DD ?  
COUNT       EQU 00H  
VACANT      EQU 00H  
```

### TYPICAL BSP INITIALIZATION SEQUENCE

在BSP和AP通过硬件协议选择完成后（参见第7.5.3节“Intel Xeon处理器的MP初始化协议算法”），BSP开始在正常的IA-32架构启动地址（FFFF FFF0H）执行BIOS引导代码（POST）。引导代码通常执行以下操作：

1. **初始化内存**。
2. **将微码更新加载到处理器中**。
3. **初始化MTRR**。
4. **启用缓存**。
5. **执行CPUID指令，EAX寄存器值为0H，然后读取EBX、ECX和EDX寄存器以确定BSP是否为“GenuineIntel”**。
6. **执行CPUID指令，EAX寄存器值为1H，然后将EAX、ECX和EDX寄存器中的值保存到RAM中的系统配置空间以备后用**。
7. **将AP的启动代码加载到内存低1MB中的4KB页面中**。
8. **切换到保护模式，并确保APIC地址空间映射为强不可缓存（UC）内存类型**。
9. **从本地APIC ID寄存器中确定BSP的APIC ID（默认为0）**：
   ```
   MOV ESI, APIC_ID ; 本地APIC ID寄存器的地址
   MOV EAX, [ESI]
   AND EAX, 0FF000000H ; 清零除APIC ID外的所有位
   MOV BOOT_ID, EAX ; 保存到内存中
   ```
   将APIC ID保存到ACPI和MP表中，并可选地保存到RAM中的系统配置空间。
10. **将AP启动代码的4KB页面的基地址转换为8位向量**。8位向量定义了实地址模式地址空间（1MB空间）中的4KB页面的地址。例如，向量0BDH指定启动内存地址为000BD000H。
11. **通过设置APIC伪向量寄存器（SVR）的第8位来启用本地APIC**：
    ```
    MOV ESI, SVR ; SVR的地址
    MOV EAX, [ESI]
    OR EAX, APIC_ENABLED ; 设置第8位以启用（复位时为0）
    MOV [ESI], EAX
    ```
12. **通过为APIC错误处理程序建立8位向量来设置LVT错误处理条目**：
    ```
    MOV ESI, LVT3
    MOV EAX, [ESI]
    AND EAX, FFFFFF00H ; 清除之前的向量
    OR EAX, 000000xxH ; xx是APIC错误处理程序的8位向量
    MOV [ESI], EAX
    ```
13. **将锁信号量变量VACANT初始化为00H**。AP使用此信号量来确定它们执行BIOS AP初始化代码的顺序。
14. **执行以下操作以设置BSP检测系统中AP的存在和处理器数量**：
    - 将COUNT变量的值设置为1。
    - 启动一个定时器（设置为大约100毫秒的间隔）。在AP BIOS初始化代码中，AP将增加COUNT变量以指示其存在。当定时器到期时，BSP检查COUNT变量的值。如果定时器到期且COUNT变量未增加，则表示没有AP存在或发生了某些错误。
15. **向AP广播INIT-SIPI-SIPI IPI序列以唤醒并初始化它们**：
    ```
    MOV ESI, ICR_LOW ; 加载ICR低双字的地址到ESI
    MOV EAX, 000C4500H ; 加载广播INIT IPI到所有AP的ICR编码到EAX
    MOV [ESI], EAX ; 向所有AP广播INIT IPI
    ; 10毫秒延迟循环
    MOV EAX, 000C46XXH ; 加载广播SIPI IPI到所有AP的ICR编码到EAX，其中xx是步骤8中计算的向量值
    MOV [ESI], EAX ; 向所有AP广播SIPI IPI
    ; 200微秒延迟循环
    MOV [ESI], EAX ; 向所有AP广播第二个SIPI IPI
    ; 200微秒延迟循环
    ```
16. **等待定时器中断**。
17. **读取并评估COUNT变量，建立处理器计数**。
18. **如有必要，重新配置APIC并继续执行适当的剩余系统诊断**。

### TYPICAL AP INITIALIZATION SEQUENCE

当 AP 接收到 **SIPI** 时，它开始在 **SIPI** 中编码的向量处执行 BIOS AP 初始化代码。AP 初始化代码通常执行以下操作：
1. **等待 BIOS 初始化锁信号量**。当获得信号量的控制权时，初始化继续。  
2. **将微码更新加载到处理器中**。  
3. **初始化 MTRR**（使用与 BSP 相同的映射）。  
4. **启用缓存**。  
5. **执行 CPUID 指令**，**EAX** 寄存器中的值为 0H，然后读取 **EBX**、**ECX** 和 **EDX** 寄存器以确定 AP 是否为“GenuineIntel”。  
6. **执行 CPUID 指令**，**EAX** 寄存器中的值为 1H，然后将 **EAX**、**ECX** 和 **EDX** 寄存器中的值保存到 RAM 中的系统配置空间中，以供以后使用。  
7. **切换到保护模式**，并确保 APIC 地址空间映射到强不可缓存（UC）内存类型。  
8. **从本地 APIC ID 寄存器中确定 AP 的 APIC ID**，并将其添加到 MP 和 ACPI 表中，可选地添加到 RAM 中的系统配置空间。  
9. **初始化和配置本地 APIC**，通过在 **SVR** 寄存器中设置位 8 并设置 **LVT3**（错误 LVT）以进行错误处理（如第 7.5.4.1 节“典型 BSP 初始化序列”中的步骤 9 和 10 所述）。  
10. **配置 AP 的 SMI 执行环境**（每个 AP 和 BSP 必须具有不同的 **SMBASE** 地址）。  
11. **将 COUNT 变量增加 1**。  
12. **释放信号量**。  
13. **执行 CLI 和 HLT 指令**。  
14. **等待 INIT IPI**。  

#### 7.5.5. 识别 MP 系统中的处理器  
在 BIOS 完成 MP 初始化协议后，每个处理器都可以通过其本地 APIC ID 唯一标识。软件可以通过以下任一方式访问这些 APIC ID：
- **读取本地 APIC 的 APIC ID**。在处理器上运行的代码可以执行 **MOV** 指令来读取处理器的本地 APIC ID 寄存器的内容（参见第 8.4.6 节“本地 APIC ID”）。  
- **读取 ACPI 或 MP 表**。作为 MP 初始化协议的一部分，BIOS 创建 ACPI 表和 MP 表。这些表在《多处理器规范版本 1.4》中定义，为软件提供系统中处理器及其本地 APIC ID 的列表。ACPI 表的格式源自 ACPI 规范，这是 MP 系统的行业标准电源管理和平台配置规范。  

对于 Intel Xeon 处理器，在电源启动和初始化期间分配给处理器的 APIC ID 为 8 位（参见图 7-2）。在这里，位 1 和位 2 形成一个 2 位处理器标识符（也可以视为插槽标识符）。在配置为集群的系统中，位 3 和位 4 形成一个 2 位集群 ID。位 0 在 Intel Xeon 处理器 MP 中用于标识封装内的两个逻辑处理器（参见第 7.6.8 节“识别 MP 系统中的逻辑处理器”）。对于不支持超线程技术的 Intel Xeon 处理器，位 0 始终设置为 0；对于支持超线程技术的 Intel Xeon 处理器，位 0 的功能与 Intel Xeon 处理器 MP 中的功能相同。

![](/static/images/2502/p062.png)

对于P6系列处理器，在上电和初始化期间分配给处理器的APIC ID为4位（参见图7-2）。其中，第0位和第1位形成2位处理器（或插槽）标识符，第2位和第3位形成2位集群ID。