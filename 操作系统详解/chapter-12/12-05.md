# CONTROL REGISTERS

![](/static/images/2502/p025.png)

![](/static/images/2502/p026.png)

控制寄存器（CR0、CR1、CR2、CR3和CR4，参见图2-5）决定了处理器的操作模式和当前执行任务的特性，具体如下：

- **CR0**：包含控制处理器操作模式和状态的系统控制标志。
- **CR1**：保留。
- **CR2**：包含页错误线性地址（导致页错误的线性地址）。
- **CR3**：包含页目录基地址的物理地址和两个标志（PCD和PWT）。该寄存器也称为页目录基址寄存器（PDBR）。仅指定页目录基地址的最高20位；地址的低12位假定为0。因此，页目录必须对齐到页（4KB）边界。PCD和PWT标志控制页目录在处理器内部数据缓存中的缓存（它们不控制页目录信息的TLB缓存）。  
  当使用物理地址扩展时，CR3寄存器包含页目录指针表的基地址（参见第3.8节“使用PAE分页机制的36位物理寻址”）。
- **CR4**：包含一组标志，用于启用多个架构扩展，并指示操作系统或执行程序对特定处理器能力的支持。

控制寄存器可以使用MOV指令的加载或存储形式进行读取和加载（或修改）。在保护模式下，MOV指令允许读取或加载控制寄存器（仅在特权级0）。此限制意味着应用程序或操作系统过程（在特权级1、2或3运行）无法读取或加载控制寄存器。  
加载控制寄存器时，保留位应始终设置为之前读取的值。

控制寄存器中标志的功能如下：

**PG 分页标志（CR0的第31位）**  
设置为启用分页；清除以禁用分页。当分页禁用时，所有线性地址被视为物理地址。如果CR0的PE标志（第0位）未设置，PG标志无效；事实上，在PE标志清除时设置PG标志会导致生成一般保护异常（#GP）。有关处理器分页机制的详细描述，请参见第3.6节“分页（虚拟内存）概述”。

**CD 缓存禁用标志（CR0的第30位）**  
当CD和NW标志清除时，启用处理器内部（和外部）缓存对整个物理内存的缓存。当CD标志设置时，缓存受到限制，如表10-5所述。为防止处理器访问和更新其缓存，必须设置CD标志并使缓存无效，以确保不会发生缓存命中（参见第10.5.3节“防止缓存”）。有关对选定页或内存区域缓存的额外限制的详细描述，请参见第10.5节“缓存控制”。

**NW 非写通标志（CR0的第29位）**  
当NW和CD标志清除时，启用写回（对于Pentium 4、Intel Xeon、P6系列和Pentium处理器）或写通（对于Intel486处理器）缓存，并启用无效周期。有关NW标志在其他CD和NW标志设置下对缓存影响的详细信息，请参见表10-5。

**AM 对齐掩码标志（CR0的第18位）**  
设置为启用自动对齐检查；清除以禁用对齐检查。仅当AM标志设置、EFLAGS寄存器中的AC标志设置、CPL为3且处理器处于保护模式或虚拟8086模式时，才会执行对齐检查。

**WP 写保护标志（CR0的第16位）**  
设置为禁止超级用户级过程写入用户级只读页；清除以允许超级用户级过程写入用户级只读页。此标志有助于实现操作系统（如UNIX*）用于创建新进程（分叉）的写时复制方法。

**NE 数值错误标志（CR0的第5位）**  
设置为启用x87 FPU错误的本地（内部）报告机制；清除以启用PC风格的x87 FPU错误报告机制。当NE标志清除且IGNNE#输入被置位时，x87 FPU错误被忽略。当NE标志清除且IGNNE#输入未被置位时，未屏蔽的x87 FPU错误会导致处理器置位FERR#引脚以生成外部中断，并在执行下一个等待的浮点指令或WAIT/FWAIT指令之前立即停止指令执行。FERR#引脚用于驱动外部中断控制器的输入（FERR#引脚模拟Intel 287和Intel 387 DX数学协处理器的ERROR#引脚）。NE标志、IGNNE#引脚和FERR#引脚与外部逻辑一起用于实现PC风格的错误报告。（有关x87 FPU错误报告的更多信息，请参见第8章“软件异常处理”以及《IA-32 Intel架构软件开发手册》第1卷的附录D，FERR#引脚何时置位取决于具体实现。）

**ET 扩展类型标志（CR0的第4位）**  
在Pentium 4、Intel Xeon、P6系列和Pentium处理器中保留。（在Pentium 4、Intel Xeon和P6系列处理器中，此标志硬编码为1。）在Intel386和Intel486处理器中，此标志设置为指示支持Intel 387 DX数学协处理器指令。

**TS 任务切换标志（CR0的第3位）**  
允许在任务切换时延迟保存x87 FPU、MMX、SSE和SSE2上下文，直到新任务实际执行x87 FPU、MMX、SSE或SSE2指令。处理器在每次任务切换时设置此标志，并在执行x87 FPU、MMX、SSE和SSE2指令时测试它。  
- 如果TS标志设置且EM标志（CR0的第2位）清除，则在执行任何x87 FPU、MMX、SSE和SSE2指令之前会引发设备不可用异常（#NM），PAUSE、PREFETCHh、SFENCE、LFENCE、MFENCE、MOVNTI和CLFLUSH指令除外。（有关WAIT/FWAIT指令的特殊情况，请参见下文。）  
- 如果TS标志设置且MP标志（CR0的第1位）和EM标志清除，则在执行x87 FPU WAIT/FWAIT指令之前不会引发#NM异常。  
- 如果EM标志设置，TS标志的设置不会影响x87 FPU、MMX、SSE和SSE2指令的执行。  
表2-1显示了处理器根据TS、EM和MP标志的设置遇到x87 FPU指令时采取的操作。表11-1和表12-1分别显示了处理器遇到MMX指令或SSE/SSE2指令时采取的操作。  
处理器不会在任务切换时自动保存x87 FPU、XMM和MXCSR寄存器的上下文。相反，它设置TS标志，这会导致处理器在遇到新任务指令流中的x87 FPU、MMX、SSE或SSE2指令时引发#NM异常（上述列出的指令除外）。  
#NM异常的故障处理程序可用于清除TS标志（使用CLTS指令）并保存x87 FPU、XMM和MXCSR寄存器的上下文。如果任务从未遇到x87 FPU、MMX、SSE或SSE2指令，则x87 FPU、MMX、SSE和SSE2上下文永远不会保存。

**EM 仿真标志（CR0的第2位）**  
设置为指示处理器没有内部或外部x87 FPU；清除以指示存在x87 FPU。此标志还影响MMX、SSE和SSE2指令的执行。  
当EM标志设置时，执行x87 FPU指令会生成设备不可用异常（#NM）。当处理器没有内部x87 FPU或未连接到外部数学协处理器时，必须设置此标志。设置此标志会强制所有浮点指令由软件仿真处理。表9-2显示了根据系统中IA-32处理器和x87 FPU或数学协处理器的存在，此标志的推荐设置。表2-1显示了EM、MP和TS标志的交互。  
此外，当EM标志设置时，执行MMX指令会导致生成无效操作码异常（#UD）（参见表11-1）。因此，如果IA-32处理器包含MMX技术，则必须将EM标志设置为0以启用MMX指令的执行。  
同样，对于SSE和SSE2扩展，当EM标志设置时，执行大多数SSE和SSE2指令会导致生成无效操作码异常（#UD）（参见表12-1）。因此，如果IA-32处理器包含SSE和/或SSE2扩展，则必须将EM标志设置为0以启用这些扩展的执行。不受EM标志影响的SSE和SSE2指令是PAUSE、PREFETCHh、SFENCE、LFENCE、MFENCE、MOVNTI和CLFLUSH指令。

**MP 监控协处理器标志（CR0的第1位）**  
控制WAIT（或FWAIT）指令与TS标志（CR0的第3位）的交互。如果MP标志设置，则当TS标志设置时，WAIT指令会生成设备不可用异常（#NM）。如果MP标志清除，WAIT指令会忽略TS标志的设置。表9-2显示了根据系统中IA-32处理器和x87 FPU或数学协处理器的存在，此标志的推荐设置。表2-1显示了MP、EM和TS标志的交互。

**PE 保护启用标志（CR0的第0位）**  
设置为启用保护模式；清除以启用实地址模式。此标志不直接启用分页。它仅启用段级保护。要启用分页，必须同时设置PE和PG标志。有关使用PE标志在实模式和保护模式之间切换的信息，请参见第9.9节“模式切换”。

**PCD 页级缓存禁用标志（CR3的第4位）**  
控制当前页目录的缓存。当PCD标志设置时，禁止页目录的缓存；当标志清除时，页目录可以被缓存。此标志仅影响处理器的内部缓存（L1和L2，如果存在）。如果未使用分页（CR0中的PG标志清除）或CR0中的CD（缓存禁用）标志设置，处理器会忽略此标志。有关此标志使用的更多信息，请参见第10章“内存缓存控制”。有关页目录和页表项中PCD标志的描述，请参见第3.7.6节“页目录和页表项”。

**PWT 页级写通标志（CR3的第3位）**  
控制当前页目录的写通或写回缓存策略。当PWT标志设置时，启用写通缓存；当标志清除时，启用写回缓存。此标志仅影响内部缓存（L1和L2，如果存在）。如果未使用分页（CR0中的PG标志清除）或CR0中的CD（缓存禁用）标志设置，处理器会忽略此标志。有关此标志使用的更多信息，请参见第10.5节“缓存控制”。有关页目录和页表项中PCD标志的描述，请参见第3.7.6节“页目录和页表项”。

**VME 虚拟8086模式扩展标志（CR4的第0位）**  
设置为在虚拟8086模式下启用中断和异常处理扩展；清除以禁用扩展。使用虚拟模式扩展可以通过消除调用虚拟8086监视器处理执行8086程序时发生的中断和异常的开销来提高虚拟8086应用程序的性能，而是将中断和异常重定向回8086程序的处理程序。它还提供了虚拟中断标志（VIF）的硬件支持，以提高在多任务和多处理器环境中运行8086程序的可靠性。有关此功能使用的详细信息，请参见第16.3节“虚拟8086模式中的中断和异常处理”。

**PVI 保护模式虚拟中断标志（CR4的第1位）**  
设置为在保护模式下启用虚拟中断标志（VIF）的硬件支持；清除以禁用保护模式下的VIF标志。有关此功能使用的详细信息，请参见第16.4节“保护模式虚拟中断”。

**TSD 时间戳禁用标志（CR4的第2位）**  
设置为限制RDTSC指令在特权级0的过程执行；清除以允许在任何特权级执行RDTSC指令。

**DE 调试扩展标志（CR4的第3位）**  
设置为在引用调试寄存器DR4和DR5时生成未定义操作码（#UD）异常；清除时，处理器将对DR4和DR5寄存器的引用别名为兼容早期IA-32处理器上运行的软件。有关此标志功能的更多信息，请参见第15.2.2节“调试寄存器DR4和DR5”。

**PSE 页大小扩展标志（CR4的第4位）**  
设置为启用4MB页；清除以将页限制为4KB。有关此标志使用的更多信息，请参见第3.6.1节“分页选项”。

**PAE 物理地址扩展标志（CR4的第5位）**  
设置为启用分页机制以引用36位物理地址；清除以将物理地址限制为32位。有关物理地址扩展的更多信息，请参见第3.8节“使用PAE分页机制的36位物理寻址”。

**MCE 机器检查启用标志（CR4的第6位）**  
设置为启用机器检查异常；清除以禁用机器检查异常。有关机器检查异常和机器检查架构的更多信息，请参见第14章“机器检查架构”。

**PGE 页全局启用标志（CR4的第7位）**  
（在P6系列处理器中引入。）设置为启用全局页功能；清除以禁用全局页功能。全局页功能允许将频繁使用或共享的页标记为对所有用户全局（通过页目录或页表项中的全局标志，第8位完成）。全局页在任务切换或写入CR3寄存器时不会从转换后备缓冲器（TLB）中刷新。  
启用全局页功能时，必须在设置PGE标志之前启用分页（通过设置CR0中的PG标志）。颠倒此顺序可能会影响程序正确性，并影响处理器性能。有关此位使用的更多信息，请参见第3.11节“转换后备缓冲器（TLB）”。

**PCE 性能监控计数器启用标志（CR4的第8位）**  
设置为允许在任何保护级别运行的程序或过程执行RDPMC指令；清除时，RDPMC指令只能在保护级别0执行。

**OSFXSR 操作系统对FXSAVE和FXRSTOR指令的支持标志（CR4的第9位）**  
设置时，此标志执行以下功能：（1）向软件指示操作系统支持使用FXSAVE和FXRSTOR指令，（2）启用FXSAVE和FXRSTOR指令以保存和恢复XMM和MXCSR寄存器的内容以及x87 FPU和MMX寄存器的内容，（3）启用处理器执行任何SSE和SSE2指令，PAUSE、PREFETCHh、SFENCE、LFENCE、MFENCE、MOVNTI和CLFLUSH指令除外。  
如果此标志清除，FXSAVE和FXRSTOR指令将保存和恢复x87 FPU和MMX指令的内容，但可能不会保存和恢复XMM和MXCSR寄存器的内容。  
此外，如果此标志清除，处理器在尝试执行任何SSE和SSE2指令时会生成无效操作码异常（#UD），PAUSE、PREFETCHh、SFENCE、LFENCE、MFENCE、MOVNTI和CLFLUSH指令除外。操作系统或执行程序必须显式设置此标志。  
**注意**  
CPUID功能标志FXSR、SSE和SSE2（第24、25和26位）分别指示特定IA-32处理器上FXSAVE/FXRESTOR指令、SSE扩展和SSE2扩展的可用性。OSFXSR位为操作系统软件提供了一种启用这些功能并指示操作系统支持这些功能的手段。

**OSXMMEXCPT 操作系统对未屏蔽SIMD浮点异常的支持标志（CR4的第10位）**  
指示操作系统支持通过异常处理程序处理未屏蔽的SIMD浮点异常，当生成SIMD浮点异常（#XF）时调用该处理程序。SIMD浮点异常仅由SSE和SSE2 SIMD浮点指令生成。操作系统或执行程序必须显式设置此标志。如果此标志未设置，处理器在检测到未屏蔽的SIMD浮点异常时会生成无效操作码异常（#UD）。

## CPUID Qualification of Control Register Flags

控制寄存器 CR4 中的 VME、PVI、TSD、DE、PSE、PAE、MCE、PGE、PCE、OSFXSR 和 OSXMMEXCPT 标志是特定于型号的。在使用这些标志之前（PCE 标志除外），可以通过 CPUID 指令来确定它们是否在处理器上实现。
