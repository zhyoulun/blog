# SYSTEM INSTRUCTION SUMMARY

系统指令处理系统级功能，例如加载系统寄存器、管理缓存、管理中断或设置调试寄存器。许多这些指令只能由操作系统或执行程序（即在特权级0运行的过程）执行。其他指令可以在任何特权级执行，因此可用于应用程序。表2-2列出了系统指令，并指示它们是否对应用程序可用且有用。这些指令在《IA-32 Intel架构软件开发手册》第2卷第3章“指令集参考”中有详细描述。

![](/static/images/2502/p027.png)

注释：
对在 CPL 为 1 或 2 运行的应用程序有用。
控制寄存器 CR4 中的 TSD 和 PCE 标志控制在 CPL 为 3 运行的应用程序对这些指令的访问。
这些指令是在 Pentium 处理器中引入 IA-32 架构的。
该指令是在 Pentium Pro 处理器和带有 MMX™技术的 Pentium® 处理器中引入 IA-32 架构的。

## Loading and Storing System Registers

GDTR、LDTR、IDTR 和 TR 寄存器各自都有加载和存储指令，用于将数据加载到寄存器中或从寄存器中存储数据：
LGDT（加载 GDTR 寄存器）
将 GDT 基地址和限长从内存加载到 GDTR 寄存器中。
SGDT（存储 GDTR 寄存器）
将 GDTR 寄存器中的 GDT 基地址和限长存储到内存中。
LIDT（加载 IDTR 寄存器）
将 IDT 基地址和限长从内存加载到 IDTR 寄存器中。
SIDT（加载 IDTR 寄存器）
将 IDTR 寄存器中的 IDT 基地址和限长存储到内存中。
LLDT（加载 LDT 寄存器）
将 LDT 段选择子和段描述符从内存加载到 LDTR 中。（段选择子操作数也可以位于通用寄存器中。）
SLDT（存储 LDT 寄存器）
将 LDTR 寄存器中的 LDT 段选择子存储到内存或通用寄存器中。
LTR（加载任务寄存器）
将 TSS 的段选择子和段描述符从内存加载到任务寄存器中。（段选择子操作数也可以位于通用寄存器中。）
STR（存储任务寄存器）
将任务寄存器中当前任务 TSS 的段选择子存储到内存或通用寄存器中。
**LMSW（加载机器状态字）和SMSW（存储机器状态字）** 指令操作控制寄存器 CR0 的第 0 位到第 15 位。这些指令是为了与 16 位 Intel 286 处理器兼容而提供的。为在 32 位 IA-32 处理器上运行的程序不应使用这些指令。相反，它们应使用 MOV 指令访问控制寄存器 CR0。
**CLTS（清除 CR0 中的 TS 标志）** 指令用于处理设备不可用异常（#NM），该异常在处理器尝试执行浮点指令且 TS 标志被设置时发生。此指令允许在保存 x87 FPU 上下文后清除 TS 标志，从而防止进一步的 #NM 异常。有关 TS 标志的更多信息，请参见第 2.5 节 “控制寄存器”。
控制寄存器（CR0、CR1、CR2、CR3 和 CR4）使用 MOV 指令加载。该指令可以从通用寄存器加载控制寄存器，或将控制寄存器的内容存储到通用寄存器中。

## Verifying of Access Privileges

处理器提供了几条指令用于检查段选择子和段描述符，以确定是否允许访问其关联的段。这些指令复制了处理器自动执行的一些访问权限和类型检查功能，从而使操作系统或执行程序能够防止生成异常。

**ARPL（调整RPL）指令**  
调整段选择子的RPL（请求者特权级别）以匹配提供段选择子的程序或过程的RPL。有关此指令功能和使用的详细说明，请参见第4.10.4节“检查调用者访问权限（ARPL指令）”。

**LAR（加载访问权限）指令**  
验证指定段的可访问性，并将段描述符中的访问权限信息加载到通用寄存器中。软件随后可以检查访问权限以确定段类型是否与其预期用途兼容。有关此指令功能和使用的详细说明，请参见第4.10.1节“检查访问权限（LAR指令）”。

**LSL（加载段限长）指令**  
验证指定段的可访问性，并将段描述符中的段限长加载到通用寄存器中。软件随后可以将段限长与段内偏移量进行比较，以确定偏移量是否位于段内。有关此指令功能和使用的详细说明，请参见第4.10.3节“检查指针偏移量是否在限长内（LSL指令）”。

**VERR（验证可读）和VERW（验证可写）指令**  
分别验证所选段在CPL下是否可读或可写。有关此指令功能和使用的详细说明，请参见第4.10.2节“检查读/写权限（VERR和VERW指令）”。

## Loading and Storing Debug Registers

处理器内部的调试功能由一组 8 个调试寄存器（DR0 到 DR7）控制。MOV 指令允许将设置数据加载到这些寄存器中或从这些寄存器中存储数据。

## Invalidating Caches and TLBs

处理器提供了几条指令用于显式使其缓存和TLB条目无效。**INVD（无写回无效缓存）指令**使内部缓存中的所有数据和指令条目无效，并向外部缓存发送信号，指示它们也应无效。

**WBINVD（写回无效缓存）指令**执行与INVD指令相同的功能，不同之处在于它在使缓存无效之前将内部缓存中的任何修改行写回内存。在使内部缓存无效后，它向外部缓存发出信号，要求其写回修改的数据并使其内容无效。

**INVLPG（无效TLB条目）指令**使指定页的TLB条目无效（刷新）。

## Controlling the Processor

**HLT（暂停处理器）指令** 会停止处理器，直到接收到一个已启用的中断（例如通常启用的NMI或SMI）、调试异常、BINIT#信号、INIT#信号或RESET#信号。处理器会生成一个特殊的总线周期以指示已进入暂停模式。硬件可以以多种方式响应此信号。前面板上的指示灯可能会亮起，可能会生成用于记录诊断信息的NMI中断，或者可能会调用复位初始化（注意，BINIT#引脚是在Pentium Pro处理器中引入的）。如果在关机期间有任何非唤醒事件挂起，它们将在处理来自关机的唤醒事件后进行处理（例如，A20M#中断）。

**LOCK前缀** 在修改内存操作数时调用锁定（原子）的读-修改-写操作。此机制用于在多处理器系统中实现处理器之间的可靠通信。在Pentium处理器及更早的IA-32处理器中，LOCK前缀会使处理器在指令执行期间置位LOCK#信号，这总是会导致显式的总线锁定。在Pentium 4、Intel Xeon和P6系列处理器中，锁定操作通过缓存锁定或总线锁定来处理。如果内存访问是可缓存的并且只影响单个缓存行，则会调用缓存锁定，并且在操作期间不会锁定系统总线和系统内存中的实际内存位置。在这种情况下，总线上的其他Pentium 4、Intel Xeon或P6系列处理器会根据需要写回任何修改的数据并使其缓存无效，以保持系统内存的一致性。如果内存访问不可缓存和/或跨越缓存行边界，则处理器的LOCK#信号会被置位，并且在锁定操作期间处理器不会响应总线控制请求。

**RSM（从SMM返回）指令** 将处理器（从上下文转储中）恢复到系统管理模式（SMM）中断之前的状态。

## Reading Performance-Monitoring and Time-Stamp Counters

**RDPMC（读取性能监控计数器）** 和 **RDTSC（读取时间戳计数器）** 指令允许应用程序分别读取处理器的性能监控计数器和时间戳计数器。

Pentium 4 和 Intel Xeon 处理器有 18 个 40 位的性能监控计数器，而 P6 系列处理器有 2 个 40 位的计数器。这些计数器可用于记录事件的发生次数或事件的持续时间。可以监控的事件是特定于型号的，包括解码的指令数量、接收的中断数量、缓存加载的数量等。每个计数器可以设置为监控不同的事件，使用系统指令 WRMSR 在 45 个 ESCR 和 18 个 CCCR MSR（对于 Pentium 4 和 Intel Xeon 处理器）或 PerfEvtSel0 或 PerfEvtSel1 MSR（对于 P6 系列处理器）中设置值。RDPMC 指令将计数器中的当前计数值加载到 EDX:EAX 寄存器中。

时间戳计数器是一个特定于型号的 64 位计数器，每次处理器复位时都会被重置为零。如果没有复位，当处理器以 200 MHz 的时钟频率运行时，计数器每年会增加约 6.3 x 10^15 次。在此时钟频率下，计数器需要超过 2000 年才会回绕。RDTSC 指令将时间戳计数器的当前计数值加载到 EDX:EAX 寄存器中。

有关性能监控和时间戳计数器的更多信息，请参见第 15.8 节“性能监控概述”和第 15.7 节“时间戳计数器”。

RDTSC 指令是在 Pentium 处理器中引入 IA-32 架构的。RDPMC 指令是在 Pentium Pro 处理器和带有 MMX 技术的 Pentium 处理器中引入 IA-32 架构的。早期的 Pentium 处理器有两个性能监控计数器，但它们只能通过 RDMSR 指令读取，并且只能在特权级 0 下读取。

## Reading and Writing Model-Specific Registers

**RDMSR（读取模型特定寄存器）** 和 **WRMSR（写入模型特定寄存器）** 指令允许分别读取和写入处理器的 64 位模型特定寄存器（MSR）。要读取或写入的 MSR 由 ECX 寄存器中的值指定。RDMSR 指令从指定的 MSR 中读取值并将其存储到 EDX:EAX 寄存器中；WRMSR 指令将 EDX:EAX 寄存器中的值写入指定的 MSR。有关 MSR 的更多信息，请参见第 9.4 节“模型特定寄存器（MSR）”。

RDMSR 和 WRMSR 指令是在 Pentium 处理器中引入 IA-32 架构的。
