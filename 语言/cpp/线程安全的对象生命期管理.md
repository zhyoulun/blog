## 析构函数和多线程

编写线程安全的类不是难事，用同步原语（synchronization primitives）保护内部状态即可。但是对象的生与死不能由对象自身拥有的mutex（互斥器）来保护。如何避免对象析构时，可能存在的race condition（竞争条件）是C++多线程编程面临的基本问题，可以借助boost库中的shared_ptr和weak_ptr完美解决。这也是实现线程安全的observer模式的必备技术。

与其它面向对象语言不同，C++要求程序员自己管理对象的生命期，这在多线程环境下显得尤其困难。当一个对象能被多个线程同时看到时，那么对象的销毁实际就会变得模糊不清，可能出现多种竞争条件：

- 在即将析构一个对象时，从何而知此刻是否有别的线程正在执行该对象的成员函数？
- 如何保证在执行成员函数期间，对象不会在另一个线程中被析构？
- 在调用某个对象的成员函数之前，如何得知这个对象还活着？它的析构函数会不会碰巧执行到一半？

解决这些竞争条件是C++多线程面临的基本问题。本文试图以shared_ptr一劳永逸的解决这些问题，减轻C++多线程编程的精神负担。

## 线程安全

一个线程安全的class应当满足如下三个条件：

- 多线程同时访问时，其表现出正确的行为
- 无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织
- 调用端代码无需额外的同步或其他协调动作

